# title: "Знакомство с R"
# author: "Марина Варфоломеева"

# ## Клавиатурные сокращения в RStudio =====================
#
# - `Ctrl + Shift + C` - закомментировать/раскомментировать
# выделенный фрагмент кода.
# - `Ctrl + Enter` - отправляет строку из текстового
# редактора в консоль, а если выделить несколько строк, то
# будет выполнен этот фрагмент кода.
# - `Tab` или `Ctrl + Space` - нажмите после того как начали
# набирать название функции или переменной, и появится
# список автоподстановки. Это помогает печатать код быстро и
# с меньшим количеством ошибок.

# # Установка дополнительных пакетов =======================

## # Из репозитория CRAN
install.packages("ggplot2")
install.packages("readxl")

# ## Математические операции================================
2 + 3
36 / 2
7 * 4
5 ^ 2

# Для некоторых операций есть специальные функции:
sqrt(27)

# #### Задание 1 ---------------------------------------
#
# Найдите длину гипотенузы прямоугольного треугольника со
# сторонами 3 и 5 см.


# #### Задание 2 ---------------------------------------
#
# Извлеките кубический корень из 27.

# ## Предупреждения и ошибки (warnings and errors)==========
sqrt(-27)
sqr(27)

# ## Помощь в R=============================================

sqrt() # поставить курсор на название функции и нажать `F1`
?sqrt
help("sqrt")


# ### Задание 3 ---------------------------------------

# Что делает функция `round()`?

# ### Задание 4 ---------------------------------------
#
# Посмотрите в справку к функции `log()`. Какое основание
# логарифма используется в R по умолчанию?


# ## Переменные (variables) ================================

num_1 <- 1024 / 2
num_1
1238 * 3 -> num_2  # экзотический вариант
num_2


# Осторожно, переменные можно случайно или намеренно перезаписать
num_1
num_1 <- 2^2
num_1

# Код --- это линейная последовательность действий

# Пример 1
## # Неправильно:
box_wt <- 1.2
apples <- 6
box / apples # ошибка. переменная box еще не была создана.
# нужная переменная называется box_wt.


# Пример 2
# Неправильно:
box <- 1.3
box / fruits # ошибка. переменная fruits еще не была создана.
fruits <- 7


#### Задание 5 ---------------------------------------------

# Переставьте строки так, чтобы код можно было выполнить без ошибки.

distance <- 120
speed <- distance / time
time <- 6


# #### Задание 6  ------------------------------------------
#
# Ширина прямоугольника 2 см, а длина на 7 см больше. Чему
# равен периметр? (В решении создайте и используйте
# переменные `width`, `len` и `per`).



# ## Типы данных в R ==========================

# Числовые данные. Мы только что их видели.

# ### Текстовые данные (`character`)
"это текст"
'это тоже текст'

# ### Логические данные (`logical`)

TRUE # истина
FALSE # ложь

# Для ленивых. Но лучше так не делать.
T
F


# ### Встроенные в R константы

# `NA` --- англ _"not available"_.
NA + 2
NA * 0
NA / 0
sqrt(NA)

# `Inf` --- _"infinity"_ --- бесконечность.
1 / 0

# `NaN` --- _"not a number"_.
0 / 0
sqrt(-1)

# `NULL` --- ноль, т.е. это значит "пусто", "ничего нет".


# # Основные структуры данных в R ==========================

# ## Векторы (vectors) =====================================

23
sqrt(25)


# ### Создание векторов из произвольных элементов

# Функция `c()`
c(2, 4, 6)
c(-9.3, 0, 2.17, 21.3)

# Векторы можно хранить в переменных
vect_num <- c(2, 4, 6, 8, 10, 12, 14, 16)
vect_num_1 <- c(1.3, 1.7, NA, 0.9, 1.6, 1.4)

# Можно объединять несколько векторов
c(1, 1, 5:9)
c(vect_num, vect_num_1)
c(100, vect_num)

# Векторы могут содержать не только числа, но и логические значения, текст.
c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
colours <- c("red", "orange", "yellow", "green", "blue", "violet")

#
# #### Задание 7 ---------------------------------------
#
# Создайте вектор, в котором будут буквами закодированы
# нуклеотиды ДНК в алфавитном порядке.



# #### Задание 8 ---------------------------------------
#
# Создайте вектор, в котором будет три наименьших
# отрицательных целых числа в порядке возрастания.




# ### Создание векторов из целых чисел подряд
#
# Оператор `:`

1:10 # от одного до 10
-5:3 # от -5 до 3



# #### Задание 9 ---------------------------------------
#
# Создайте вектор из целых чисел от 1 до 100. Как вы
# думаете, что означают номера в квадратных скобках в начале
# каждой строки?



# ### Создание векторов из повторяющихся элементов

# Функция `rep()`

rep(x = 1, times = 3) # 1 повторяется 3 раза
rep(x = "red", times = 5) # "red" повторяется 5 раз
rep(x = TRUE, times = 2) # TRUE повторяется 2 раза

rep(TRUE, 5) # TRUE повторяется 5 раз, аргументы без названий

# Создаем логический вектор, где `TRUE` повторяется 3 раза,
# `FALSE` 3 раза и `TRUE` 4 раза. Результат сохраняем в
# переменной `vect_log`.
vect_log <- c(rep(TRUE, 3), rep(FALSE, 3), rep(TRUE, 4))
vect_log


# #### Задание 10 ---------------------------------------
#
# Создайте вектор `season` в котором названия времен года
# будут следовать в том же порядке, что и месяцы года, к
# которым они относятся (начиная с января).



# ### Адресация внутри векторов
#
# При помощи оператора `[]`

vect_num # весь вектор
vect_num[1] # первый элемент
vect_num[3] # 3-й элемент

# Если нужно несколько элементов
colours # весь вектор
colours[3:5] # 3-5 элемент

# Если нужны элементы не подряд
vect_num[c(2, 4, 6)]
colours[c(1, 6)]

# Вектор --- одномерный объект
vect_num[2, 4, 6] # Ошибка
colours[1, 6] # Ошибка

# Обращение к несуществующему элементу
vect_num[198]

# Встроенные константы (см. `?Constants`).
LETTERS
letters
month.abb
month.name

# #### Задание 11 --------------------------------------
#
# Извлеките из вектора `month.name`
#
# - летние месяцы,
# - зимние месяцы.



# #### Задание 12 --------------------------------------
#
# Извлеките из вектора LETTERS буквы в таком порядке, чтобы
# получилось слово `SUN`.



# ### Операции с векторами
#
# Проверим, как работают арифметические операции
vect_num + 2
vect_num * 2
vect_num * (-2)
vect_num^2


# С самими векторами тоже можно делать некоторые операции.
sum(vect_num)
length(vect_num)
mean(vect_num)
min(vect_num)

# #### Задание 13 --------------------------------------
#
# Создайте переменную `powers_of_two`, в которой сохраните
# последовательность из целочисленных степеней двойки --- с
# первой по пятую. Используйте векторизацию. Выведите
# содержимое `powers_of_two` в консоль.




# ## Матрицы (matrices)==========================

# Матрица с числовыми данными
matrix(data = 1:12, nrow = 4)
# Матрица с текстовыми данными
matrix(data = LETTERS[1:12], ncol = 6)

# Обычно элементы записываются в матрицу столбцами
matrix(data = 1:6, ncol = 3)
# Порядок заполнения матрицы элементами можно изменить, если указать `byrow = TRUE`.
matrix(data = 1:6, ncol = 3, byrow = TRUE)

# ### Адресация в матрицах

# Поскольку матрицы --- это двумерные объекты, первым в
# квадратных скобках следует номер строки, вторым --- номер
# столбца
mat <- matrix(data = LETTERS[1:12], ncol = 3)
mat
mat[3, 2]
mat[1, ]
mat[, 3]
mat[, -1]
mat[1:3, c(1, 3)]

# #### Задание 14  --------------------------------------
#
# Создайте матрицу `calendar` с названиями месяцев, так,
# чтобы в первой строке был первый квартал.



# #### Задание 15 --------------------------------------
#
# Выберите из матрицы `calendar` месяцы третьего квартала.



# #### Задание 16 --------------------------------------
#
# Выберите из матрицы `calendar` июнь.



# ## Массивы (arrays)==========================
#
# Массивы --- это многомерные объекты

ar <- array(data = 1:24, dim = c(2, 4, 3))
ar

ar[1, 2, 3]
ar[, , 1]
ar[, 1, ]
ar[1, , ]
ar[1, 1:3, 1]
ar[, , -1]

# ## Датафреймы (data frames)==========================

# Датафреймы --- это такие двумерные таблицы, в которых
# столбцы могут содержать данные разных типов.

x <- 2014:2017
y <- LETTERS[1:4]
z <- c(TRUE, TRUE, FALSE, TRUE)
dat <- data.frame(year = x, type = y, test_passed = z, stringsAsFactors = FALSE)
dat


# ### Адресация в датафреймах
#
# Оператор `[]` с числами

dat[2, 2]

# Оператор `[]` с числовыми или текстовыми векторами
dat[, c("year", "test_passed")]

# Оператор `$`
dat$year

# Можно использовать комбинацию предыдущих техник.
dat$test_passed[3]



# #### Задание 17 --------------------------------------
#
# Создайте датафрейм `year`, в котором будет две переменные:
# `month` и `season`.



# #### Задание 18 --------------------------------------
#
# Выберите из датафрейма `year`
#
# - строки, соответствующие весенним месяцам
# - время года, которому соответствует июнь
# - всю колонку, кодирующую сезон



# ## Списки (lists)==========================
#
# Данные различных типов, и разной длины.
list(dat, mat, vect_num, colours)

# Можно создавать именованные списки
lst <- list(Dfr = dat, Matr = mat, Vect1 = vect_num, Vect2 = colours)
lst

# ### Адресация в списках

# оператор `[]`
lst[1:2] # список из двух элементов
lst[1] # список из одного элемента

# двойные квадратные скобки `[[]]`
lst[[1]]
lst[[1]]$v2

# оператор `$`
lst$Vect1
lst$Matr[, 1]

#
# # Факторы (factors) --- особый тип данных ================


# Факторы - это способ хранения дискретных (= категориальных данных).

snail_colours <- c("red", "green", "green", "green", "yellow", "yellow", "yellow", "yellow")
snail_colours # это текстовый вектор.

f_snail_alphabet <- factor(snail_colours)
f_snail_alphabet

# Уровни этого фактора: `1 - green`, `2 - red`, `3 - yellow`

# Можно изменить порядок уровней
f_snail_ryg <- factor(snail_colours, levels = c("red", "yellow", "green"))
f_snail_ryg
f_snail_yrg <- relevel(f_snail_ryg, ref = "yellow")
f_snail_yrg


# #### Задание 19 --------------------------------------
#
# Из вектора `season`, созданного ранее, создайте фактор
# `season_f` с алфавитным порядком уровней.



# #### Задание 20 --------------------------------------
#
# Из вектора `season`, созданного ранее, создайте фактор
# `season_f` , в котором уровни следуют в том же порядке,
# что и времена года в году.



# #### Задание 21
#
# Из вектора `season`, созданного ранее, создайте фактор
# `season_f`, в котором уровни следуют в том же порядке, что
# и времена года в году, и называются первыми двумя буквами.



# # Работа с логическими данными==========================
#
# ## Операторы сравнения
# - `==` --- равно
# - `>` --- больше
# - `<` --- меньше
# - `!=` ---  не равно
# - `>=` --- больше или равно
# - `<=` --- меньше или равно
# - функции на `is` (например, `is.numeric()`, `is.na()`)
# - оператор сопоставления `%in%` и т.п.
?Comparison # справка об операторах сравнения
?match      # о сопоставлении

vect_num # ранее созданный вектор

vect_num > 8

vect_num != 2

# ## Логические операторы

# `&` --- логическое "И":
# `|` --- логическое "ИЛИ":
# `!` --- логическое отрицание:
?Logic # Справка о логических операторах


# Пример:
vect_num # ранее созданный вектор

(vect_num != 2) & (vect_num < 8)

season # ранее созданный вектор

season == "spring"


# #### Задание 22 --------------------------------------
#
# При помощи вектора `season`, создайте логический вектор,
# где `TRUE` стоит везде, кроме зимних месяцев.




# ## Отбор данных с помощью логических векторов ============

# месяц, который называется "June".
month.name[month.name == "June"]

# только весенние месяцы
month.name[season == "spring"]

# строки с зимними месяцами из датафрейма `year`
year[year$season == "winter", ]

# только значение переменной `month` с зимними месяцами
year$month[year$season == "winter"]
year[year$season == "winter", "month"]



# Следующие несколько заданий используют данные о
# продолжительности сна млекопитающих (датасет `msleep` из
# пакета `ggplot2`). Данные можно загрузить так:
library(ggplot2) # активируем пакет ggplot2
data("msleep")   # активируем встроенный датасет msleep


# #### Задание 23 --------------------------------------
# Добудьте из `msleep` английские названия видов, у которых
# общая продолжительность сна больше 15 часов.


# #### Задание 24 --------------------------------------
# По данным `msleep` посчитайте, какова средняя
# продолжительность сна хищников.


# #### Задание 25 --------------------------------------
# По данным `msleep` посчитайте, какова минимальная
# продолжительность сна травоядных.


# #### Задание 26 --------------------------------------
# По данным `msleep` найдите, у какого животного минимальная
# продолжительность сна.


# # Как узнать, к какому классу структур данных относится содержимое переменной? =======

# функция `class()`
class(f_snail_alphabet)
class(vect_log)
class(vect_num)
class(colours)
class(mat)
class(ar)
class(dat)
class(lst)

# # Приведение (coercion), проверка принадлежности к классу/типу.=========

# Функции для конверсии на `as...()`.
# Функции для проверки на `is...()`

vect_num
as.character(vect_num)

vect_log
as.numeric(vect_log)
as.character(vect_log)
as.character(as.numeric(vect_log))

as.numeric(as.character(vect_log))

is.character(vect_num)
is.numeric(vect_num)
is.logical(vect_log)

is.vector(vect_log)
is.matrix(vect_log)
as.matrix(vect_log)

is.matrix(mat)
is.array(dat)
as.data.frame(mat)


# # Функции (functions)=====================================


# Вспомним, как выглядят наши векторы
vect_num
vect_num_1

mean(vect_num)
mean(vect_num_1)

mean(vect_num_1, na.rm = TRUE)

# Попробуем написать пользовательскую функцию `my_mean()`,
# которая будет по умолчанию считать среднее значение
# элементов в векторе с учетом пропущенных значений (`NA`)
my_mean <- function(x){
  mean(x, na.rm = TRUE)
  }

# Иногда у функций бывает еще инструкция `return()`
my_mean <- function(x){
  res <- mean(x, na.rm = TRUE)
  return(res)
}

# Любую пользовательскую функцию нужно протестировать
mean(vect_num_1, na.rm = TRUE)
my_mean(vect_num_1)



# ## Чтение из текстовых файлов ==========================

dat <- read.table(file = "data/expression_3.csv", header = TRUE, sep = ",", dec = ".")

# После открытия файла стоит убедится, все ли правильно прочитано.
head(dat)

# Правильно ли R определил классы переменных?
sapply(dat, class)

# Странным образом, столбцы `X2` и `X6` были преобразованы в факторы
dat1 <- within(dat, {
  X2 <- as.numeric(as.character(X2))
  X6 <- as.numeric(as.character(X6))
}
)

# Отфильтруем значения в старом датафрейме, на месте которых
# получились NA.
dat$X2[is.na(dat1$X2)]
dat$X6[is.na(dat1$X6)]
# Видно, что в исходном файле пропущенные значения были
# обозначены `-`.

# Проверим, правильно ли определены типы переменных после
# преобразования.
sapply(dat1, class)

# Теперь все правильно.


# ## Чтение из архивированных файлов =======================
dat2 <- read.table(unz("./data/expression_3.zip", "expression_analysis/3.csv"), header=T, sep=",", stringsAsFactors = FALSE)
head(dat2)
sapply(dat2, class)
# Дальше все те же самые манипуляции, что мы проделывали в
# прошлом разделе.


# ## Чтение файлов Excel ===================================
library(readxl)
dat3 <- read_excel(path = "data/expression_3.xlsx")


# В пакете `readxl` используется более совершенный алгоритм
# автоматического определения классов переменных.
sapply(dat3, class)
sum(is.na(dat3$`2`))
sum(is.na(dat3$`6`))

# `readxl` пытается сохранить исходные названия переменных
colnames(dat3)

# Мы можем создать свои собственные имена переменных.
new_names <- paste0("X", colnames(dat3))
colnames(dat3) <- new_names


