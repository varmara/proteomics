<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Марина Варфоломеева" />


<title>Анализ протеомных данных с использованием R</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<script src="libs/htmlwidgets-1.3/htmlwidgets.js"></script>
<script src="libs/viz-0.3/viz.js"></script>
<link href="libs/DiagrammeR-styles-0.2/styles.css" rel="stylesheet" />
<script src="libs/grViz-binding-1.0.0/grViz.js"></script>

<style type="text/css">

/* don't use link color in navbar */
.dropdown-menu>li>a {
  color: black;
}

/* some padding for disqus */
#disqus_thread {
  margin-top: 45px;
}

</style>

<link rel="stylesheet" href="libs/font-awesome-4.1.0/css/font-awesome.min.css"/>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; } /* Alert */
code span.an { color: #008000; } /* Annotation */
code span.at { } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #0000ff; } /* ControlFlow */
code span.ch { color: #008080; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; } /* Comment */
code span.cv { color: #008000; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #0000ff; } /* Keyword */
code span.op { } /* Operator */
code span.ot { color: #ff4000; } /* Other */
code span.pp { color: #ff4000; } /* Preprocessor */
code span.sc { color: #008080; } /* SpecialChar */
code span.ss { color: #008080; } /* SpecialString */
code span.st { color: #008080; } /* String */
code span.va { } /* Variable */
code span.vs { color: #008080; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<div class="container-fluid main-container">

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/proteomics-course/">Proteomics course</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="index.html">Начало</a></li>
        <li class="dropdown">
          <a href="lecture-notes" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Конспект<span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
<!--             <li class="dropdown-header">Начало работы</li>
--->
             <li><a href="00_introduction.html">О модуле Анализ протеомных данных</a></li>
             <li class="divider"></li>
             <li><a href="01_introduction_to_r.html">Знакомство с R</a></li>
             <li><a href="02_data_preprocessing.html">Предварительная обработка данных</a></li>
             <li><a href="03_classification.html">Классификация</a></li>
             <li><a href="04_differential_expression_analysis.html">Выявление дифференциально-экспрессируемых пептидов</a></li>
<!--
             <li><a href="05_multivariate_methods_pca.html">Многомерные методы (PCA)</a></li>
--->
<!--             <li><a href="06_multivariate_methods_pls-da.html">Многомерные методы (PLS-DA)</a></li>
-->
            <li class="divider"></li>
            <li><a href="protocol.html">Протокол анализа данных</a></li>
          </ul>
        </li>
        <li><a href="resources.html">Ссылки и ресурсы</a></li>
        <li><a href="coding_practices.html">Правила хорошего кода</a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Анализ протеомных данных с использованием R</h1>
<h4 class="author"><em>Марина Варфоломеева</em></h4>

</div>


<div id="----r" class="section level2">
<h2>Анализ протеомных данных в R</h2>
</div>
<div id="--" class="section level2">
<h2>Формат записи данных</h2>
<p>Результаты измерения интенсивности пятен на гелях обычно записываются в виде нескольких таблиц:</p>
<ul>
<li>Данные об интенсивности пятен (data) — таблица <span class="math inline"><em>p</em> × <em>n</em></span>, где записаны интенсивности <em>p</em> белков (строки) для каждого из <em>n</em> гелей (столбцы).</li>
<li>Данные о пробах (factors) — таблица <span class="math inline"><em>n</em> × <em>q</em></span>, в которой для каждой из <em>n</em> проб записана информация о <em>q</em> свойствах (об экспериментальных факторах, повторностях и т.д.).</li>
<li>Данные о свойствах белков (proteins) — таблица <span class="math inline"><em>p</em> × <em>m</em></span>, где для <em>p</em> белков (строки) записаны <em>m</em> свойств (столбцы).</li>
<li>Данные об эксперименте в целом (experiment) — таблица произвольной длины, в которой содержатся свойства эксперимента и их значения (например, информация об экспериментальном объекте, имя экспериментатора, ссылка на публикацию и т.п.).</li>
</ul>
<div class="figure">
<img src="images-meth/data-format.png" alt="Формат записи данных" />
<p class="caption">Формат записи данных</p>
</div>
</div>
<div id="--" class="section level2">
<h2>Протокол анализа данных</h2>
<ol style="list-style-type: decimal">
<li>Правильно ли открылись данные? Правильно ли определены типы переменных?</li>
<li>Сколько белков и сколько проб в файле с экспрессией? Для всех ли проб указаны значения факторов в файле с факторами? (т.е. соответствует ли число строк в файле с факторами числу столбцов в файле с экспрессией?)</li>
<li>Сколько групп закодировано в каждом факторе? Сколько проб входит в каждую из групп?</li>
<li>Сколько пропущенных значений экспрессии для каждого из белков? Если есть пропуски — проводим импутацию пропущенных значений.</li>
<li>Трансформируем сырые данные экспрессии при помощи двоичного логарифма.</li>
<li>Нужна ли нормализация? RI-plot или боксплот. Если нужно — нормализуем.</li>
<li>(Не обязательно, но возможно) Разведочный анализ (ординация методом главных компонент), чтобы выяснить нет ли таких отдельных белков или проб, которые сильно отличаются от других. На этой стадии можно выявить технические ошибки.</li>
<li>Усредняем технические повторности.</li>
<li>Строим дендрограмму проб. Получаем значения бутстреп поддержки ветвей (и/или считаем другие индексы оценки качества кластеризации).</li>
<li>Проводим анализ дифференциальной экспрессии. Полную таблицу дифференциально-экспрессируемых белков можно включить в приложения. Краткую таблицу и/или тепловую карту экспрессии всех дифференциальных белков можно включить в текст.</li>
</ol>
<p>В итоге у вас должны получится:</p>
<ul>
<li>Дендрограмма проб.</li>
<li>Таблица дифференциально-экспрессируемых белков (краткая или полная).</li>
<li>Тепловая карта экспрессии дифференциальных белков.</li>
</ul>
</div>
<div id="----pecten-maximus" class="section level2">
<h2>Пример: протеом жабр гребешка <em>Pecten maximus</em></h2>
<p>Мы рассмотрим различные техники анализа на примере данных о протеоме жабр гребешка <em>Pecten maximus</em>. Гребешков подвергали воздействию двух разных температур (15 и 25 градусов, по 6 гребешков в каждой группе). В этом исследовании на гелях было обнаружено в общей сложности 766 пятен. Данные о протеоме жабр гребешка содержатся в пакете prot2D <span class="citation">(Artigaud et al. 2013)</span>, который можно инсталлировать с Bioconductor.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(prot2D)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span>(pecten)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span>(pecten.fac)</a></code></pre></div>
<p>В датафрейме <code>pecten</code> хранятся необработанные данные интенсивностей пятен (<em>raw volume data</em>)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">dim</span>(pecten)</a></code></pre></div>
<pre><code>## [1] 766  12</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">head</span>(pecten, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##     Br_23865 Br_23883 Br_23884 Br_23728 Br_23729 Br_23730 Br_23731
## 126  4917372  3700556  5602088  1039165 16948657  5301985  4630511
## 155   629380   538182   542741   550110  1400204  3507947  7428518
##     Br_23732 Br_23733 Br_23875 Br_23876 Br_23877
## 126 12969625  2869155  1771437  2707717  7120168
## 155  2445648   947371   412389   398940   380115</code></pre>
<p>В датафрейме <code>pecten.fac</code> описана принадлежность гребешков к разным вариантам экспериментальной обработки. В данном случае, всего один фактор — <code>Condition</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">dim</span>(pecten.fac)</a></code></pre></div>
<pre><code>## [1] 12  1</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">head</span>(pecten.fac)</a></code></pre></div>
<pre><code>##          Condition
## Br_23865       15C
## Br_23883       15C
## Br_23884       15C
## Br_23728       15C
## Br_23729       15C
## Br_23730       15C</code></pre>
</div>
<div id="-" class="section level2">
<h2>Предварительная обработка</h2>
<div id="--" class="section level3">
<h3>Импутация пропущенных значений</h3>
<p>Довольно часто бывает так, что в матрице экспрессии могут пустовать некоторые ячейки. Пятно может быть обнаружено на одном геле, но отсутствовать на других в силу различных причин. Например, в силу различий между биологическими репликами, из-за различий между техническими репликами по техническим причинам, из-за ошибок в идентификации пятен, из-за плохой изоэлектрической фокусировки, из-за малого количества белка и т.п.</p>
<p>Отсутствие пятна на геле может обозначать разные вещи: белок может действительно отсутствовать, либо он отсутствует в силу технических причин, либо он все же присутствует в концентрации ниже порога определения. Отсутствие пятна на всех технических повторностях может скорее означать отсутствие белка — в таких ячейках можно записать нули. Однако, если пропущенные значения появились в результате неправильного сопоставления пятен, то замена их нулями может исказить данные. Если мы имеем дело с истинно пропущенными значениями, то такие ячейки мы оставим пустыми, а R во время чтения данных автоматически преобразует их в <code>NA</code> (специальное обозначение пропущенных данных, от англ. <em>not available</em>).</p>
<p>Как поступать с пропущенными значениями? Есть несколько возможных вариантов. (а) Исключение переменных, в которых есть пропущенные значения (использование только “надежных” белков) сильно снижает “интересность” анализа, потому что многие белки будут исключены, и в результате останется меньше пятен. (б) Замена пропущенных значений средними значениями экспрессии данного белка в разных образцах (mean substitution). Это довольно грубый вариант, который вносит искажения в данные. (в) Замена <code>NA</code> средним по <em>k</em>-ближайшим соседям — очень хорший метод импутации <span class="citation">(<em>k-nearest neighbour averaging</em>; Troyanskaya et al. 2001)</span>. Как работает этот методы мы разберем подробнее и потом потренируемся его использовать.</p>
</div>
<div id="-----k--" class="section level3">
<h3>Импутация методом замены средним по <em>k</em>-ближайшим соседям</h3>
<p>Метод импутации по k-ближайшим соседям заменяет каждое пропущенное значение взвешенным средним, рассчитанным по <em>k</em>-ближайшим белкам-соседям, у которых это значение не пропущено <span class="citation">(Troyanskaya et al. 2001)</span></p>
<p>Допустим, у белка <em>#1</em> есть пропущенное значение экспрессии в пробе <em>A</em>. Алгоритм вначале находит <em>k</em> белков с похожим паттерном экспрессии (соседей). Соседство определяется при помощи евклидова расстояния между белками, рассчитанного по пробам с известным уровнем экспрессии. Далее, в пробе <em>А</em> рассчитывается взвешенное среднее уровней экспрессии этих <em>k</em> похожих белков. Вклад каждого белка взвешивают по степени его сходства с белком <em>#1</em>.</p>
<p>Может случиться так, что у некоторых похожих белков есть пропущенные значения интенсивности экспрессии в некоторых других пробах. В этом случае, сходство между белками определяется как среднее сходств, рассчитанных по пробам без пропущенных для этих белков данных. Наконец, если вдруг так оказалость, что у нескольких похожих белков неизвестна интенсивность экспрессии в одной и той же пробе, тогда пропущенные значения алгоритм заменяет средним значением интенсивности по пробе.</p>
</div>
<div id="--k----r" class="section level3">
<h3>Импутация по k-ближайшим соседям в R</h3>
<p>Для импутации используют данные по всем техническим и биологическим репликам. После импутации можно будет усреднить технические реплики, либо анализировать их отдельно.</p>
<p>В нашем примере пропущенных значений нет. В этом легко убедиться при помощи комбинации из нескольких функций.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">colSums</span>(<span class="kw">is.na</span>(pecten))</a></code></pre></div>
<pre><code>## Br_23865 Br_23883 Br_23884 Br_23728 Br_23729 Br_23730 Br_23731 Br_23732 
##        0        0        0        0        0        0        0        0 
## Br_23733 Br_23875 Br_23876 Br_23877 
##        0        0        0        0</code></pre>
<p>Функция <code>is.na()</code> — проверяет, равно ли значение ее аргумента <code>NA</code> и возвращает логическое значение. <code>is.na(pecten)</code> вернет двумерную таблицу, в которой <code>TRUE</code> будет встречаться, только если соответствующий элемент в датафрейме <code>pecten</code> был <code>NA</code>. Логическим значениям <code>TRUE</code> и <code>FALSE</code> соответствуют 1 и 0. Если мы посчитаем суммы значений в каждом из столбцов таблицы при помощи функции <code>colSums()</code>, то мы получим число <code>NA</code> для каждого из них.</p>
<p>Чтобы можно было сейчас продемонстрировать, как работает импутация пропущенных значений, нам потребуется, чтобы в датасете <code>pecten</code> всетаки они были, поэтому мы специально заменим случайно выбранные ячейки на <code>NA</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co"># &quot;Портим&quot; данные пропущенными значениями.</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">dim</span>(pecten)</a></code></pre></div>
<pre><code>## [1] 766  12</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">id &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9192</span>, <span class="dt">size =</span> <span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">spect &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(pecten)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">spect[id] &lt;-<span class="st"> </span><span class="ot">NA</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="co"># Вот что получилось</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="kw">colSums</span>(<span class="kw">is.na</span>(spect))</a></code></pre></div>
<pre><code>## Br_23865 Br_23883 Br_23884 Br_23728 Br_23729 Br_23730 Br_23731 Br_23732 
##       83       80       90       93       91       66       85       81 
## Br_23733 Br_23875 Br_23876 Br_23877 
##       79       79       93       80</code></pre>
<p>Теперь можно приступать к тренировке заполнения пропущенных значений. Метод <em>k</em>-ближайших соседей реализован в пакете <code>impute</code> на Bioconductor <span class="citation">(Hastie et al. 2018)</span>.</p>
<p>Для импутации при помощи среднего по <em>k</em>-ближайшим соседям матрицу интенсивностей сначала нужно транспонировать, чтобы пробы были в строках, а белки в столбцах.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">library</span>(impute)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co"># транспонируем, чтобы белки были в столбцах</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">trans_spect &lt;-<span class="st"> </span><span class="kw">t</span>(spect) </a>
<a class="sourceLine" id="cb16-4" data-line-number="4">knn_dat &lt;-<span class="st"> </span><span class="kw">impute.knn</span>(trans_spect, <span class="dt">k =</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="co"># в результате импудации получился сложный объект - список</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="kw">str</span>(knn_dat)</a></code></pre></div>
<pre><code>## List of 3
##  $ data     : num [1:12, 1:766] 4917372 3700556 5602088 1039165 16948657 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : chr [1:12] &quot;Br_23865&quot; &quot;Br_23883&quot; &quot;Br_23884&quot; &quot;Br_23728&quot; ...
##   .. ..$ : chr [1:766] &quot;126&quot; &quot;155&quot; &quot;168&quot; &quot;285&quot; ...
##  $ rng.seed : num 3.62e+08
##  $ rng.state: int [1:626] 403 376 621607385 1291405879 -972665800 -1220233665 -2003166808 -375148988 -423220417 -853866428 ...</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co"># импутированные данные содержатся в элементе data</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">ipect_knn &lt;-<span class="st"> </span><span class="kw">t</span>(knn_dat<span class="op">$</span>data)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="co"># Теперь нет пропущенных значений</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="kw">colSums</span>(<span class="kw">is.na</span>(ipect_knn))</a></code></pre></div>
<pre><code>## Br_23865 Br_23883 Br_23884 Br_23728 Br_23729 Br_23730 Br_23731 Br_23732 
##        0        0        0        0        0        0        0        0 
## Br_23733 Br_23875 Br_23876 Br_23877 
##        0        0        0        0</code></pre>
</div>
<div class="section level3">
<h3>Логарифмирование</h3>
<p>Обычно исследователей интересует оотношение уровней экспрессии. Беда в том, что отношение несимметрично относительно 1. Например, пусть в пробе A уровень экспрессии 10, а в пробе B — 1. Если мы посчитаем соотношение уровней экспрессии <span class="math inline"><em>A</em>/<em>B</em> = 10/1 = 10</span>, если наоборот <span class="math inline"><em>B</em>/<em>A</em> = 1/10 = 0.1</span>. Уровень экспрессии в пробе А в 10 раз больше, чем в B, но величина соотношения зависит от порядка действий — это неудобно. Если мы будем использовать логарифмы, эта проблема исчезнет. Логарифм соотношения равен разнице логарифмов: <span class="math inline"><em>l</em><em>o</em><em>g</em><sub>10</sub>(<em>A</em>/<em>B</em>) = <em>l</em><em>o</em><em>g</em><sub>10</sub>(<em>A</em>) − <em>l</em><em>o</em><em>g</em><sub>10</sub>(<em>B</em>) = 10 − 1 = 9</span>, аналогично <span class="math inline"><em>l</em><em>o</em><em>g</em><sub>10</sub>(<em>B</em>/<em>A</em>) = <em>l</em><em>o</em><em>g</em><sub>10</sub>(<em>B</em>) − <em>l</em><em>o</em><em>g</em><sub>10</sub>(<em>A</em>) = 1 − 10 =  − 9</span>. Разница логарифмов распределена симметрично вокруг нуля, от порядка действий зависит только знак.</p>
<p>Обычно данные логарифмируют по основанию 2. С логарифмами по основанию 2 принято работать из-за удобства вычислений (числа получаются меньше по абсолютной величине) и удобства интерпретации (если мы считаем разницу логарифмов экспрессии в опыте и контроле и она равна единице, то это означает, что экспрессия различается в два раза). Подробнее об этом можно прочесть в разделе <em>Соотношение уровней экспрессии</em>.</p>
<p>Если в ваших исходных данных есть нули, то можно перед логарифмированием прибавить к ним небольшую константу, чтобы не получить <code>-Inf</code>. Т.е. преборазовать <code>log2(x + 1)</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co"># Логарифмируем данные</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">pecten_log &lt;-<span class="st"> </span><span class="kw">log2</span>(pecten)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="co"># создаем палитру и вектор цветов</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="kw">library</span>(RColorBrewer)</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">pal &lt;-<span class="st"> </span><span class="kw">brewer.pal</span>(<span class="dv">9</span>, <span class="st">&quot;Set1&quot;</span>)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">cols &lt;-<span class="st"> </span>pal[pecten.fac<span class="op">$</span>Condition]</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="co"># Сторим боксплот</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="kw">boxplot</span>(pecten_log, <span class="dt">outline =</span> <span class="ot">FALSE</span>, <span class="dt">boxwex =</span> <span class="fl">0.7</span>, <span class="dt">notch =</span> T, <span class="dt">col =</span> cols, <span class="dt">main =</span> <span class="st">&quot;Логарифмированные</span><span class="ch">\n</span><span class="st">данные&quot;</span>)</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"><span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="kw">levels</span>(pecten.fac<span class="op">$</span>Condition), <span class="dt">fill =</span> pal, <span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">xpd =</span> T)</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
</div>
<div class="section level3">
<h3>Нормализация</h3>
<p>Для того, чтобы выровнять форму распределений, применяют квантильную нормализацию. Во время квантильной нормализации сначала для значений экспрессии в каждой пробе вычисляют ранги. Затем, значения одинакового ранга заменяют их средними значениями интенсивности экспрессии. Так, например, максимальные значения экспрессии в пробах станут средним максимальных значений, медианые значения экспрессии в пробах станут средним значением медиан и так далее.</p>
<p>Теперь давайте применим квантильную нормализацию к данным о протеоме гребешков.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">library</span>(limma)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">pecten_norm &lt;-<span class="st"> </span><span class="kw">normalizeQuantiles</span>(pecten_log)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="kw">boxplot</span>(pecten_norm, <span class="dt">outline =</span> <span class="ot">FALSE</span>, <span class="dt">boxwex =</span> <span class="fl">0.7</span>, <span class="dt">notch =</span> T, <span class="dt">col =</span> cols, <span class="dt">main =</span> <span class="st">&quot;Нормализованные данные&quot;</span>)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="kw">levels</span>(pecten.fac<span class="op">$</span>Condition), <span class="dt">fill =</span> pal, <span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">xpd =</span> T)</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>После нормализации размах варьирования величин экспрессии в разных образцах выравнялся</p>
<!-- ### Сохранение данных после предварительной обработки -->
<!-- Сохранение файлов с данными в R -->
<!-- ```{r, eval=FALSE} -->
<!-- write.csv(pecten_norm, file = "pecten_log2_normalized.csv") -->
<!-- ``` -->
</div>
</div>
<div id="------." class="section level2">
<h2>Иерархическая классификация проб на основании различий экспрессии.</h2>
<p>Классификация данных проходит в несколько этапов. Вначале формируется набор признаков, на основании которых нужно провести классификацию объектов. В нашем случае объекты — это пробы, уровень экспрессии белков в пробах — признаки объектов. На основании этих признаков будет рассчитана матрица коэффициентов различия или сходства между всем объектами, и объекты будут сгруппированы в кластеры по определенным правилам (алгоритм кластеризации). Качество финальной классификации можно оценить различными способами.</p>
<p>Результат кластеризации будет сильнее всего зависеть (1) от выбора коэффициента сходства-различия и (2) от алгоритма кластеризации. Нет формальных способов выбрать наиболее подходящий коэффициент и алгоритм.</p>
<div id="--" class="section level3">
<h3>Коэффициенты сходства-различия</h3>
<p>Коэффициенты сходства-различия делятся на различия и сходства, причем из мер сходства легко получить меры различия и наоборот.</p>
<p>Различия</p>
<p><span class="math inline"><em>d</em> ≥ 0</span> <div id="htmlwidget-40bd89d55e984d1b2e2e" style="width:432px;height:48px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-40bd89d55e984d1b2e2e">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B\n\n  # several \"edge\" statements\n  A->B [dir = \"both\"]\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script></p>
<p>Сходства</p>
<p><span class="math inline">0 ≤ <em>S</em> ≤ 1</span> или <span class="math inline"> − 1 ≤ <em>S</em> ≤ 1</span></p>
<div id="htmlwidget-986050fd01dc1301ae5e" style="width:432px;height:48px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-986050fd01dc1301ae5e">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B\n\n  # several \"edge\" statements\n  A->B [dir = \"both\", arrowhead = inv arrowtail = inv]\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
<p>Коэффициенты сходства-различия используются в качестве исходных данных для многих видов многомерных анализов, в т.ч. для иерархического кластерного анализа. Из сходств можно получить различия и наоборот. Свои собственные коэффициенты существуют для количественных и качественных признаков. Есть несколько популярных в протеомике коэффициентов сходства-различия: для количественных данных — Евклидово расстояние, для бинарных данных — коэффициент Жаккара.</p>
<div id="-" class="section level4">
<h4>Евклидово расстояние</h4>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-11-1.png" width="384" /></p>
<p>Для двумерного пространства Евклидово расстояние рассчитывается так:</p>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-12-1.png" width="192" /></p>
<p>Т.е. Евклидово расстояние в этом гипотетическом примере будет</p>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-13-1.png" width="192" /></p>
<p>Для пространства с большим числом измерений формула Евклидова расстояния выглядит так:</p>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-14-1.png" width="192" /></p>
<p>Евклидово расстояние — это метрика.</p>
<p>Для всех метрик (расстояний) справедливы три свойства:</p>
<ol style="list-style-type: decimal">
<li>Адекватность:</li>
</ol>
<p><br /><span class="math display"><em>d</em><sub><em>A</em>, <em>A</em></sub> = 0</span><br /></p>
<div id="htmlwidget-55bbb6d8cf494cb98931" style="width:384px;height:48px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-55bbb6d8cf494cb98931">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR/*,\n  label = <<font point-size=\"10\">d<sub><font point-size=\"5\">A, A<\/font><\/sub> = 0<\/font>>*/, labelloc = t]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
<ol start="2" style="list-style-type: decimal">
<li>Симметричность:</li>
</ol>
<p><br /><span class="math display"><em>d</em><sub><em>A</em>, <em>B</em></sub> = <em>d</em><sub><em>B</em>, <em>A</em></sub></span><br /></p>
<div id="htmlwidget-d324300dc2de2afc0d8a" style="width:384px;height:48px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-d324300dc2de2afc0d8a">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR, labelloc = t, labeljust = c/*, label = \"Симметричность\"*/]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B\n\n  # several \"edge\" statements\n  A->B /*[label=<<font point-size=\"10\">d<sub><font point-size=\"5\">A, B<\/font><\/sub> = d<sub><font point-size=\"5\">B, A<\/font><\/sub><\/font>>]*/\n  B->A\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
<ol start="3" style="list-style-type: decimal">
<li>Триангулярность:</li>
</ol>
<p><br /><span class="math display"><em>d</em><sub><em>A</em>, <em>B</em></sub> ≤ <em>d</em><sub><em>A</em>, <em>C</em></sub> + <em>d</em><sub><em>C</em>, <em>B</em></sub></span><br /></p>
<p><strong>Триангулярность есть только у метрик!</strong> Именно потому, что для них выполняется неравенство треугольника, они имеют право называться <strong>расстояниями</strong>, а не просто мерами различия.</p>
<div id="htmlwidget-71fccd2d4e422e946503" style="width:384px;height:96px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-71fccd2d4e422e946503">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B; C\n\n  # several \"edge\" statements\n  A->B A->C C->B\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
</div>
<div id="-" class="section level4">
<h4>Коэффициент Жаккара</h4>
<p>Если используются бинарные данные (наличие или отсутствие экспрессии), то посчитать сходство можно, учитывая присутствие-отсутствие признаков.</p>
<table>
<thead>
<tr class="header">
<th>объект I / объект J</th>
<th>признак есть</th>
<th>признака нет</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>признак есть</td>
<td>a</td>
<td>b</td>
</tr>
<tr class="even">
<td>признака нет</td>
<td>c</td>
<td>d</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="math inline"><em>I</em></span>, <span class="math inline"><em>J</em></span> — объекты</li>
<li><span class="math inline"><em>a</em></span> — число сходств по наличию признака</li>
<li><span class="math inline"><em>b</em></span> — число отличий <span class="math inline"><em>I</em></span> от <span class="math inline"><em>J</em></span></li>
<li><span class="math inline"><em>c</em></span> — число различий <span class="math inline"><em>J</em></span> от <span class="math inline"><em>I</em></span></li>
<li><span class="math inline"><em>d</em></span> — число сходств по отсутствию признака</li>
<li><span class="math inline"><em>n</em><sub><em>J</em></sub></span> — число признаков у объекта <span class="math inline"><em>J</em></span></li>
<li><span class="math inline"><em>n</em><sub><em>I</em></sub></span> — число признаков у объекта <span class="math inline"><em>I</em></span></li>
<li><span class="math inline"><em>n</em> = <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em></span> — общее число признаков</li>
</ul>
<p>Коэффициентов сходства-различия для качественных данных придумано великое множество.</p>
<p>Коэффициент Жаккара рассчитывается по формуле:</p>
<p><span class="math inline"><em>S</em> = <em>a</em>/(<em>a</em> + <em>b</em> + <em>c</em>)</span>, причем <span class="math inline">0 ≤ <em>S</em> ≤ 1</span></p>
<p>Соответствующий коэффициент различия Жаккара можно посчитать так:</p>
<p><span class="math inline"><em>d</em> = 1 − <em>a</em>/(<em>a</em> + <em>b</em> + <em>c</em>) = (<em>b</em> + <em>c</em>)/(<em>a</em> + <em>b</em> + <em>c</em>)</span></p>
<p>У коэффициента Жаккара есть одно забавное свойство. Обратите внимание, в знаменателе фигурирует не общее число признаков — сходство по отсутствию не учитывается! Это свойство очень полезно для работы с протеомными данными. Пятно может отсутствовать на геле не только потому, что белка не было в пробе, но и в силу самых разных других причин (например, экспрессия ниже порога определения, плохо прокрашен образец и проч.).</p>
<p>Например, пусть у нас есть три пробы, у которых мы нашли всего 5 пятен.</p>
<table>
<thead>
<tr class="header">
<th align="left">Objects</th>
<th align="right">Spot.1</th>
<th align="right">Spot.2</th>
<th align="right">Spot.3</th>
<th align="right">Spot.4</th>
<th align="right">Spot.5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Object 1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="left">Object 2</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="left">Object 3</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>Чтобы оценить различие между этими пробами, можно посчитать коэффициент Жаккара.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="right">Object 1</th>
<th align="right">Object 2</th>
<th align="right">Object 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Object 1</td>
<td align="right">0.00</td>
<td align="right">0.25</td>
<td align="right">0.67</td>
</tr>
<tr class="even">
<td align="left">Object 2</td>
<td align="right">0.25</td>
<td align="right">0.00</td>
<td align="right">0.75</td>
</tr>
<tr class="odd">
<td align="left">Object 3</td>
<td align="right">0.67</td>
<td align="right">0.75</td>
<td align="right">0.00</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="-----" class="section level3">
<h3>Алгоритмы иерархической класстеризации на основании расстояний</h3>
<p>Мы рассмотрим несколько алгоритмов, которые строят иерархическую кластеризацию объектов на основании матрицы расстояний / сходств между ними: методы ближайшего соседа, отдаленного соседа, среднегруппового расстояния и метод Варда.</p>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p><strong>Метод ближайшего соседа</strong> (= nearest neighbour = single linkage) — к кластеру присоединяется ближайший к нему кластер/объект. Кластеры объединяются в один на расстоянии, которое равно расстоянию между ближайшими объектами этих кластеров. Результаты иногда сложно интерпретировать, особенно, если цель анализа заключалась в выделении групп. Объекты на дендрограмме часто не образуют четко разделенных групп, получаются цепочки кластеров (объекты присоединяются как бы по-одному). Метод хорош для выявления градиентов.</p>
<p><strong>Метод отдаленного соседа</strong> (= furthest neighbour = complete linkage) — к кластеру присоединяется отдаленный кластер/объект. Кластеры объединяются в один на расстоянии, которое равно расстоянию между самыми отдаленными объектами этих кластеров. Следствие — чем более крупная группа, тем сложнее к ней присоединиться. В результате работы этого метода на дендрограмме образуется много отдельных некрупных групп. Метод хорош для поиска дискретных групп в данных.</p>
<p><strong>Метод невзвешенного попарного среднего</strong> (= UPGMA = Unweighted Pair Group Method with Arithmetic mean) — кластеры объединяются в один на расстоянии, которое равно среднему значению всех возможных расстояний между объектами из разных кластеров.</p>
<p><strong>Метод Варда</strong> (= Ward’s Minimum Variance Clustering) — объекты объединяются в кластеры так, чтобы внутригрупповая дисперсия расстояний была минимальной. Метод годится и для неевклидовых расстояний несмотря на то, что внутригрупповая дисперсия расстояний рассчитывается так, как будто это евклидовы расстояния.</p>
</div>
<div id="---r" class="section level3">
<h3>Кластерный анализ в R</h3>
<p>Подготовим данные к кластерному анализу. Названия проб в нашем датасете <code>pecten_norm</code> — длинные непонятные аббревиатуры. Вместо них нужно создать осмысленные и краткие лейблы для проб. Информацию о лейблах возьмем из датафрейма с факторами. Температура содержания закодирована в факторе <code>pecten.fac$Condition</code>. Добавим номер к повторяющимся значениям, чтобы сделать их уникальными, при помощи функции <code>make.unique()</code>. Затем заменим старые названия проб новыми.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co"># Старые названия проб</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">colnames</span>(pecten_norm)</a></code></pre></div>
<pre><code>##  [1] &quot;Br_23865&quot; &quot;Br_23883&quot; &quot;Br_23884&quot; &quot;Br_23728&quot; &quot;Br_23729&quot; &quot;Br_23730&quot;
##  [7] &quot;Br_23731&quot; &quot;Br_23732&quot; &quot;Br_23733&quot; &quot;Br_23875&quot; &quot;Br_23876&quot; &quot;Br_23877&quot;</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co"># Новые названия проб</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">colnames</span>(pecten_norm) &lt;-<span class="st"> </span><span class="kw">make.unique</span>(<span class="kw">as.character</span>(pecten.fac<span class="op">$</span>Condition))</a></code></pre></div>
<p>Чтобы строить деревья для проб, нам понадобится транспонировать исходные данные так, чтобы пробы оказались в строках. Мы рассчитаем матрицу евклидовых расстояний между пробами, кластеризуем их разными методами.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="co"># Транспонируем данные, чтобы пробы были в строках</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">tpecten_norm &lt;-<span class="st"> </span><span class="kw">t</span>(pecten_norm)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="co"># Матрица евклидовых расстояний</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">d &lt;-<span class="st"> </span><span class="kw">dist</span>(<span class="dt">x =</span> tpecten_norm, <span class="dt">method =</span> <span class="st">&quot;euclidean&quot;</span>)</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="co"># Кластеризация разными методами</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">hc_single &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;single&quot;</span>)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">hc_compl &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;complete&quot;</span>)</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">hc_avg &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;average&quot;</span>)</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">hc_w2 &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> <span class="st">&quot;ward.D2&quot;</span>)</a></code></pre></div>
<p>Построим дендрограммы средствами базовой графики R.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1">old_par &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="kw">plot</span>(hc_single, <span class="dt">main =</span> <span class="st">&quot;Метод</span><span class="ch">\n</span><span class="st">ближайшего соседа&quot;</span>)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="kw">plot</span>(hc_compl, <span class="dt">main =</span> <span class="st">&quot;Метод</span><span class="ch">\n</span><span class="st">отдаленного соседа&quot;</span>)</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="kw">plot</span>(hc_avg, <span class="dt">main =</span> <span class="st">&quot;Метод</span><span class="ch">\n</span><span class="st">среднегруппового расстояния&quot;</span>)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="kw">plot</span>(hc_w2, <span class="dt">main =</span> <span class="st">&quot;Метод</span><span class="ch">\n</span><span class="st">Варда&quot;</span>)</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">par</span>(old_par)</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-23-1.png" width="960" /></p>
</div>
<div id="-" class="section level3">
<h3>Кофенетическая корреляция</h3>
<p>По одним и тем же исходным данным может быть построено множество вариантов дендрограмм, поскольку могут быть использованы разные коэффициенты сходства-различия и разные методы кластеризации. Любая дендрограмма — это упрощенное представление отношений между объектами. Расстояния на дендрограмме передают различия между объектами с некоторыми искажениями. Кри помощи кофенетической корреляции можно оценить, насколько кофенетические расстояния соответствуют реальным расстояниям между объектами. Кофенетическую корреляцию можно рассчитать как Пирсоновскую корреляцию (обычную) между матрицами исходных и кофенетических расстояний между всеми парами объектов. Дендрограмма с наибольшей кофенетическей корреляцией лучше всего отражает исходные данные.</p>
<p>Какая из построенных нами дендрограмм лучше отражает действительные расстояния между объектами можно оценить при помощи кофенетической корреляции. Сперва рассчитаем кофенетическое расстояние при помощи функции <code>cophenetic()</code> из пакета <code>ape</code> <span class="citation">(Paradis and Schliep 2018)</span>, затем вычислим кофенетическую корреляцию. Для данных о протеоме гребешков лучшим методом кластеризации оказывается метод среднегруппового расстояния.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">library</span>(ape)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">c_single &lt;-<span class="st"> </span><span class="kw">cophenetic</span>(<span class="kw">as.phylo</span>(hc_single))</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">c_compl &lt;-<span class="st"> </span><span class="kw">cophenetic</span>(<span class="kw">as.phylo</span>(hc_compl))</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">c_avg &lt;-<span class="st"> </span><span class="kw">cophenetic</span>(<span class="kw">as.phylo</span>(hc_avg))</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">c_w2 &lt;-<span class="st"> </span><span class="kw">cophenetic</span>(<span class="kw">as.phylo</span>(hc_w2))</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"><span class="kw">cor</span>(d, <span class="kw">as.dist</span>(c_single))</a></code></pre></div>
<pre><code>## [1] 0.9426727</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">cor</span>(d, <span class="kw">as.dist</span>(c_compl))</a></code></pre></div>
<pre><code>## [1] 0.9324593</code></pre>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">cor</span>(d, <span class="kw">as.dist</span>(c_avg))</a></code></pre></div>
<pre><code>## [1] 0.949797</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">cor</span>(d, <span class="kw">as.dist</span>(c_w2))</a></code></pre></div>
<pre><code>## [1] 0.8053291</code></pre>
<p>Мы с вами видели, что дендрограммы можно нарисовать при помощи базовой графики R, но у нее довольно мало возможностей для настройки внешнего вида. Гораздо больше возможностей для настройки у дендрограмм, построенных средствами пакета <code>dendextend</code> <span class="citation">(Galili 2015)</span>. Давайте визуализируем дендрограммы и раскрасим лейблы в разные цвета. Для того, чтобы не пришлось вручную создавать вектор цветов, можно попробовать при помощи пользовательской функции вытащить информацию из лейблов на дендрограмме. Функция <code>get_colours()</code> берет дендрограмму, экстрагирует из нее порядок лейблов, берет первые несколько букв в имени лейбла и на основании этого фактора создает вектор цветов. Теперь можно легко раскрасить группы на дендрограмме, ориентируясь на первые несколько символов в названии лейбла.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">library</span>(dendextend)</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="co"># Пользовательская функция get_colours возвращает</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="co"># вектор цветов из одной из Брюйеровских палитр</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="co"># palette, ориентируясь на первые n_chars символов</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6"><span class="co"># в названиях ветвей на дендрограмме dend</span></a>
<a class="sourceLine" id="cb35-7" data-line-number="7">get_colours &lt;-<span class="st"> </span><span class="cf">function</span>(dend, n_chars, <span class="dt">palette =</span> <span class="st">&quot;Dark2&quot;</span>){</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">  <span class="kw">library</span>(RColorBrewer)</a>
<a class="sourceLine" id="cb35-9" data-line-number="9">  <span class="kw">library</span>(dendextend)</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">  labs &lt;-<span class="st"> </span><span class="kw">get_leaves_attr</span>(dend, <span class="st">&quot;label&quot;</span>)</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">  group &lt;-<span class="st"> </span><span class="kw">substr</span>(labs, <span class="dt">start =</span> <span class="dv">0</span>, <span class="dt">stop =</span> n_chars)</a>
<a class="sourceLine" id="cb35-12" data-line-number="12">  group &lt;-<span class="st"> </span><span class="kw">factor</span>(group)</a>
<a class="sourceLine" id="cb35-13" data-line-number="13">  cols &lt;-<span class="st"> </span><span class="kw">suppressWarnings</span>(<span class="kw">brewer.pal</span>(<span class="kw">length</span>(<span class="kw">levels</span>(group)), <span class="dt">name =</span> palette))[group]</a>
<a class="sourceLine" id="cb35-14" data-line-number="14">  <span class="kw">return</span>(cols)</a>
<a class="sourceLine" id="cb35-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb35-16" data-line-number="16"></a>
<a class="sourceLine" id="cb35-17" data-line-number="17"><span class="co"># Преобразуем кластеризацию в класс dendrogram</span></a>
<a class="sourceLine" id="cb35-18" data-line-number="18">den_avg &lt;-<span class="st"> </span><span class="kw">as.dendrogram</span>(hc_avg)</a>
<a class="sourceLine" id="cb35-19" data-line-number="19"><span class="co"># Создаем вектор цветов</span></a>
<a class="sourceLine" id="cb35-20" data-line-number="20">cols &lt;-<span class="st"> </span><span class="kw">get_colours</span>(den_avg, <span class="dt">n_chars =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb35-21" data-line-number="21"><span class="co"># Раскрашиваем лейблы</span></a>
<a class="sourceLine" id="cb35-22" data-line-number="22">den_avg_c &lt;-<span class="st"> </span><span class="kw">color_labels</span>(den_avg, <span class="dt">col =</span> cols)</a>
<a class="sourceLine" id="cb35-23" data-line-number="23"><span class="co"># Рисуем дендрограмму</span></a>
<a class="sourceLine" id="cb35-24" data-line-number="24"><span class="kw">plot</span>(den_avg_c, <span class="dt">horiz =</span> <span class="ot">TRUE</span>, <span class="dt">main =</span> <span class="st">&quot;Метод</span><span class="ch">\n</span><span class="st">среднегруппового расстояния&quot;</span>)</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-25-1.png" width="960" /></p>
</div>
<div id="--" class="section level3">
<h3>Сопоставление дендрограмм: танглграмма</h3>
<p>Иногда бывает нужно сравнить несколько деревьев, построенных разными методами. Это удобно делать визуально на так называемых танглграммах. Два дерева выравнивают, вращая случайным образом ветви вокруг их оснований. Процесс повторяется много раз и каждый раз рассчитывается мера “запутанности” дендрограмм. Из множества вариантов выбирается наименее запутанный.</p>
<p>Давайте сравним дендрограммы, полученные методами ближайшего соседа и среднегруппового расстояния. У этих кластеризаций были наибольшие и довольно близкие значения кофенетического расстояния. Их дендрограммы выглядят очень похоже, отличаются только группировкой трех проб внутри одного из кластеров.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co"># Раскрасим дендрограмму, полученную методом ближайшего соседа</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">den_single &lt;-<span class="st"> </span><span class="kw">as.dendrogram</span>(hc_single)</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">cols &lt;-<span class="st"> </span><span class="kw">get_colours</span>(den_single, <span class="dt">n_chars =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">den_single_c &lt;-<span class="st"> </span><span class="kw">color_labels</span>(den_single, <span class="dt">col =</span> cols)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5"></a>
<a class="sourceLine" id="cb36-6" data-line-number="6"><span class="kw">set.seed</span>(<span class="dv">395</span>)</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">untang_w &lt;-<span class="st"> </span><span class="kw">untangle_step_rotate_2side</span>(den_single_c, den_avg_c, <span class="dt">print_times =</span> F)</a>
<a class="sourceLine" id="cb36-8" data-line-number="8"><span class="co"># танглграмма</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9"><span class="kw">tanglegram</span>(untang_w[[<span class="dv">1</span>]], untang_w[[<span class="dv">2</span>]],</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">           <span class="dt">highlight_distinct_edges =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">           <span class="dt">common_subtrees_color_lines =</span> F,</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">           <span class="dt">main =</span> <span class="st">&quot;Танглграмма</span><span class="ch">\n</span><span class="st">Евклидово расстояние&quot;</span>,</a>
<a class="sourceLine" id="cb36-13" data-line-number="13">           <span class="dt">main_left =</span> <span class="st">&quot;Метод</span><span class="ch">\n</span><span class="st">ближайшего соседа&quot;</span>,</a>
<a class="sourceLine" id="cb36-14" data-line-number="14">           <span class="dt">main_right =</span> <span class="st">&quot;Метод</span><span class="ch">\n</span><span class="st">среднегруппового расстояния&quot;</span>,</a>
<a class="sourceLine" id="cb36-15" data-line-number="15">           <span class="dt">columns_width =</span> <span class="kw">c</span>(<span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">8</span>),</a>
<a class="sourceLine" id="cb36-16" data-line-number="16">           <span class="dt">margin_top =</span> <span class="fl">3.2</span>, <span class="dt">margin_bottom =</span> <span class="fl">2.5</span>,</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">           <span class="dt">margin_inner =</span> <span class="dv">4</span>, <span class="dt">margin_outer =</span> <span class="fl">0.5</span>,</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">           <span class="dt">lwd =</span> <span class="fl">1.2</span>, <span class="dt">edge.lwd =</span> <span class="fl">1.2</span>,</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">           <span class="dt">lab.cex =</span> <span class="dv">1</span>, <span class="dt">cex_main =</span> <span class="dv">1</span>)</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/tang-1.png" width="672" /></p>
</div>
<div id="--" class="section level3">
<h3>Бутстреп поддержка ветвей</h3>
<p>Насколько часто будет воспроизводится ветвление можно оценить при помощи приблизительно несмещенного теста (“An approximately unbiased test of phylogenetic tree selection”, Shimodaria, 2002). Этот тест использует специальный вариант бутстрепа — разномасштабный бутстреп (multiscale bootstrap). Как работает этот тест? Представьте, что мы многократно делаем бутстреп выборки — случайные выборки из классифицируемых объектов с повторениями: один и тот же объект может попасть в выборку несколько раз или не попасть вообще. Для каждой такой выборки мы строим классификацию. Для каждого узла дерева можно посчитать долю классификаций, где воспроизводится это конкретное ветвление (бутстреп поддержка, BP p-value). Эта доля, BP, будет оценивать вероятность получения топологий со смещением, поскольку выборки одного размера. Чтобы лучше оценить связанную с выборочной ошибкой неопределенность топологии, можно делать разномасштабный бутстреп — выборки разного размера, т.е. с разным числом объектов. По изменению BP при разных объемах выборки можно вычислить приблизительно несмещенную оценку вероятности, с которой воспроизводится ветвление — AU (approximately unbiased p-value). Если для кластера AU p-value &gt; 0.95, то нулевую гипотезу о том, что он не существует отвергают на уровне значимости 0.05.</p>
<p>В R разномасштабный бутстреп реализован в пакете <code>pvclust</code> автором этого метода <span class="citation">(Suzuki and Shimodaira 2015)</span>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">library</span>(pvclust)</a></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co"># Итераций должно быть nboot = 1000 и больше!!!</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="co"># Здесь мало для скорости</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="kw">set.seed</span>(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">cl_boot &lt;-<span class="st"> </span><span class="kw">pvclust</span>(pecten_norm, <span class="dt">method.hclust =</span> <span class="st">&quot;average&quot;</span>, <span class="dt">nboot =</span> <span class="dv">100</span>, <span class="dt">method.dist =</span> <span class="st">&quot;euclidean&quot;</span>)</a></code></pre></div>
<pre><code>## Bootstrap (r = 0.5)... Done.
## Bootstrap (r = 0.6)... Done.
## Bootstrap (r = 0.7)... Done.
## Bootstrap (r = 0.8)... Done.
## Bootstrap (r = 0.9)... Done.
## Bootstrap (r = 1.0)... Done.
## Bootstrap (r = 1.1)... Done.
## Bootstrap (r = 1.2)... Done.
## Bootstrap (r = 1.3)... Done.
## Bootstrap (r = 1.4)... Done.</code></pre>
<p>Построим дерево с величинами поддержки при помощи средств пакета <code>dendextend</code> <span class="citation">(Galili 2015)</span></p>
<p>AU — approximately unbiased p-values (красный), BP — bootstrap p-values (зеленый)</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1">den_cl_boot &lt;-<span class="st"> </span><span class="kw">as.dendrogram</span>(cl_boot)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">cols &lt;-<span class="st"> </span><span class="kw">get_colours</span>(den_cl_boot, <span class="dt">n_chars =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">den_cl_boot_c &lt;-<span class="st"> </span><span class="kw">color_labels</span>(den_cl_boot, <span class="dt">col =</span> cols)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4"></a>
<a class="sourceLine" id="cb40-5" data-line-number="5"><span class="kw">plot</span>(den_cl_boot_c)</a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="kw">text</span>(cl_boot)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7"><span class="kw">pvrect</span>(cl_boot) <span class="co"># достоверные ветвления</span></a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-27-1.png" width="960" /></p>
<p>Но сами AU p-values оцениваются при помощи бутстрепа, а значит, тоже не точно. Стандартные ошибки AU можно оценить, чтобы оценить точность оценки самих AU. Чем больше было бутстреп-итераций, тем точнее будет оценка. Для диагностики качества оценок AU нам понадобится график стандартных ошибок для AU p-value.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">seplot</span>(cl_boot)</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="co"># seplot(cl_boot, identify = TRUE) # интерактивная идентификация значений</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="co"># print(cl_boot) # все значения</span></a></code></pre></div>
<p>Например, для кластера 2 <span class="math inline"><em>A</em><em>U</em>=</span> 0.963, а ее стандартная ошибка <span class="math inline"><em>S</em><em>E</em>=</span> 0.03. Зная стандартную ошибку можно вычислить 95% доверительный интервал для AU. Истинное значение AU p-value будет с 95% вероятностью лежать в пределах между 0.904 и 1.021. Такая оценка значимости не точна, т.к. по смыслу AU не должна быть больше 1 (<span class="math inline">0 ≤ <em>A</em><em>U</em> <em>p</em> <em>v</em><em>a</em><em>l</em><em>u</em><em>e</em> ≤ 1</span>).</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">print</span>(cl_boot, <span class="dt">which =</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>## 
## Cluster method: average
## Distance      : euclidean
## 
## Estimates on edges:
## 
##      au    bp se.au se.bp     v     c  pchi
## 2 0.963 0.935  0.03 0.009 -1.65 0.133 0.028</code></pre>
<p>Нужно увеличить число итераций.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb45-2" data-line-number="2">cl_boot &lt;-<span class="st"> </span><span class="kw">pvclust</span>(pecten_norm, <span class="dt">method.hclust =</span> <span class="st">&quot;average&quot;</span>, <span class="dt">nboot =</span> <span class="dv">1000</span>, <span class="dt">method.dist =</span> <span class="st">&quot;euclidean&quot;</span>)</a></code></pre></div>
<pre><code>## Bootstrap (r = 0.5)... Done.
## Bootstrap (r = 0.6)... Done.
## Bootstrap (r = 0.7)... Done.
## Bootstrap (r = 0.8)... Done.
## Bootstrap (r = 0.9)... Done.
## Bootstrap (r = 1.0)... Done.
## Bootstrap (r = 1.1)... Done.
## Bootstrap (r = 1.2)... Done.
## Bootstrap (r = 1.3)... Done.
## Bootstrap (r = 1.4)... Done.</code></pre>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">seplot</span>(cl_boot)</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>Если повторить бутстреп с большим числом итераций, стандартные ошибки AU p-values уменьшатся.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">print</span>(cl_boot, <span class="dt">which =</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>## 
## Cluster method: average
## Distance      : euclidean
## 
## Estimates on edges:
## 
##      au    bp se.au se.bp      v    c pchi
## 2 0.976 0.927 0.006 0.003 -1.716 0.26 0.66</code></pre>
<p>Для кластера 2 <span class="math inline"><em>A</em><em>U</em>=</span> 0.976, а ее стандартная ошибка <span class="math inline"><em>S</em><em>E</em>=</span> 0.006. Нижняя граница 95% доверительного интервала для AU 0.964, а верхняя — 0.988. Теперь мы можем доверять такой оценке AU.</p>
</div>
</div>
<div id="--" class="section level2">
<h2>Анализ дифференциальной экспрессии</h2>
<div id="--" class="section level3">
<h3>Тестирование статистических гипотез</h3>
<p>Мы хотим сравнить уровень экспрессии белков у морских гребешков, которых содержали при разной температуре. Допустим, исходя из существующих исследований и общих знаний мы предполагаем, что уровень экспрессии некоторых белков будет различаться (это то, что мы на самом деле думаем — <strong>исследовательская гипотеза</strong>). Чтобы проверить исследовательскую гипотезу, нужна <strong>нулевая гипотеза</strong>. Обычно нулевые гипотезы постулируют отсутствие каких либо различий. Так и в этом примере, нулевая гипотеза говорит, что уровень экспрессии не будет различаться.</p>
<p>Далее, мы проводим эксперимент, измеряем уровень экспрессии. После этого рассчитываем статистику, которая позволит оценить разницу уровней экспрессии в эксперименте (например, t-критерий). Наблюдаемое в эксперименте значение статистики сравнивают со значением, которое было бы получено, если бы уровни экспрессии не различались (т.е. если нулевая гипотеза верна). Если это значение маловероятно получить, когда уровни экспрессии не различаются, то мы “отвергаем” нулевую гипотезу. В таком случае, мы считаем, что результаты нашего эксперимента говорят в пользу нашей исследовательской гипотезы.</p>
</div>
<div id="----" class="section level3">
<h3>Статистические ошибки при тестировании гипотез</h3>
<p>При тестировании статистических гипотез возможно четыре варианта развития событий: мы можем принять верное решение (отвергнуть неправильную или принять верную <span class="math inline"><em>H</em><sub>0</sub></span>), или мы можем ошибиться — тоже двумя разными способами. В таблице ниже показаны типы ошибок при проверке гипотез.</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center"><span class="math inline"><em>H</em><sub>0</sub></span> == TRUE</th>
<th align="center"><span class="math inline"><em>H</em><sub>0</sub></span> == FALSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">Отклоняем <span class="math inline"><em>H</em><sub>0</sub></span></td>
<td align="center">Ошибка <strong>I</strong> рода</td>
<td align="center">Правильно</td>
</tr>
<tr class="even">
<td align="center">Сохраняем <span class="math inline"><em>H</em><sub>0</sub></span></td>
<td align="center">Правильно</td>
<td align="center">Ошибка <strong>II</strong> рода</td>
</tr>
</tbody>
</table>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/power_beta-1.png" width="384" /></p>
<p><strong>Ошибки I рода</strong> возникают тогда, когда мы ошибочно отклоняем справедливую <span class="math inline"><em>H</em><sub>0</sub></span>, т.е. находим различия там, где их нет на самом деле. Находить различия там, где их нет — значит множить сущности сверх необходимого. Поэтому вероятность ошибок I рода ученые договорились строго контролировать и следить, чтобы они появлялись не чаще, чем в 5% случаев. Иногда этот произвольно выбранный порог делают еще жестче — 1%. Вероятность ошибок I рода принято обозначать <span class="math inline"><em>α</em></span>. Это тот самый уровень значимости, с которым принято сравнивать доверительные вероятности (p-values), полученные в статистических тестах.</p>
<p><strong>Ошибки II рода</strong> возникают, когда мы ошибочно принимаем ложную <span class="math inline"><em>H</em><sub>0</sub></span>, т.е. не находим различий, там, где они на самом деле есть. Несмотря на то, что про ошибки II рода реже вспоминают, их не менее обидно делать. Считается допустимым, если такие ошибки возникают не чаще чем в 20% случаев. Это тоже совершенно произвольно взятый порог. Вероятность ошибок II рода принято обозначать <span class="math inline"><em>β</em></span>.</p>
</div>
<div id="--" class="section level3">
<h3>Мощность статистических тестов</h3>
<p><strong>Мощность теста</strong> — это способность выявлять различия, когда они есть на самом деле. Зная <span class="math inline"><em>β</em></span> можно вычислить вероятность того, что статистический тест обнаружит различия <span class="math inline"><em>P</em><em>o</em><em>w</em><em>e</em><em>r</em> = 1 − <em>β</em></span></p>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/power-1.png" width="384" /></p>
<p>Мощность любого статистического теста будет больше, если величина эффекта будет больше, если увеличить объем выборки или повысить уровень значимости (например, вместо <span class="math inline"><em>α</em> = 0.01</span>, взять <span class="math inline"><em>α</em> = 0.05</span>). На примере t-критерия зависимость мощности от этих трех величин будет выглядеть так:</p>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/pwr_vs_n-1.png" width="672" /></p>
</div>
<div id="----." class="section level3">
<h3>Способы выявления дифференциально экспрессируемых белков.</h3>
<p>Есть множество способов измерить разницу экспрессии между белками. Вот самые распространенные:</p>
<ul>
<li><strong>Соотношение уровней экспрессии</strong> (fold change) — применяется, если нет повторностей. Это очень грубый метод оценки, т.к. не позволяет оценить статистическую значимость различий.</li>
<li><strong>t-тест</strong> — у этого метода малая мощность при небольших выборках из-за неточной оценки стандартной ошибки разницы уровней экспрессии.</li>
<li><strong>Модерированный t-тест</strong> (с использованием эмпирического Байесовского метода, Empirical Bayes) — обладает большей мощностью, чем обычный t-критерий. Позволяет точнее оценить стандартную ошибку для конкретного белка, используя информацию об их распределении для всех белков.</li>
</ul>
</div>
<div id="--" class="section level3">
<h3>Соотношение уровней экспрессии</h3>
<p><strong>Соотношение уровней экспрессии</strong> (fold change, FC) — исторически первый способ оценивать дифференциальную экспрессию. Его придумали в те времена, когда делать повторности было дорого. Договорились, что будем считать, что экспрессия меняется, если ее уровень сильно отличается между группами (в 1.5 или 2 раза). Соотношение уровней экспрессии оценивает во сколько раз экспрессия в одной группе больше, чем экспрессия в другой группе. FC — это пропорция, дробь, в числителе одна группа, в знаменателе другая.</p>
<p>Соотношения уровней экспрессии требуют осторожного обращения. Давайте разберемся, почему не стоит усреднять соотношения (например, если у вас были технические повторности). Допустим, мы сравниваем уровень экспрессии до и после какого-то воздействия и у нас есть две повторности:</p>
<table>
<colgroup>
<col width="32%" />
<col width="25%" />
<col width="25%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="center"></th>
<th align="right">Повторность 1</th>
<th align="right">Повторность 2</th>
<th align="right">Среднее</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">До воздействия</td>
<td align="right"><span class="math inline"><em>A</em><sub>1</sub> = 1</span></td>
<td align="right"><span class="math inline"><em>A</em><sub>2</sub> = 10</span></td>
<td align="right"><span class="math inline"><em>Ā</em> = 5.5</span></td>
</tr>
<tr class="even">
<td align="center">После воздействия</td>
<td align="right"><span class="math inline"><em>B</em><sub>1</sub> = 10</span></td>
<td align="right"><span class="math inline"><em>B</em><sub>2</sub> = 1</span></td>
<td align="right"><span class="math inline"><em>B̄</em> = 5.5</span></td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="right"><span class="math inline"><em>A</em><sub>1</sub>/<em>B</em><sub>1</sub> = 1/10</span></td>
<td align="right"><span class="math inline"><em>A</em><sub>2</sub>/<em>B</em><sub>2</sub> = 10/1</span></td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="center">Соотношение экспрессии</td>
<td align="right"><span class="math inline">$\frac {A_{1} / B_{1}} {A_{2} / B_{2}} = \frac {1 / 10 + 10 / 1} {2} = 5.05$</span> (<strong>Неправильно!</strong>)</td>
<td align="right"></td>
<td align="right"><span class="math inline"><em>Ā</em>/<em>B̄</em> = 5.5/5.5 = 0</span> (<strong>Правильно!</strong>)</td>
</tr>
</tbody>
</table>
<p>В первой из повторностей уровень экспрессии cнизился в 10 раз (<span class="math inline">1/10</span>), а во второй — в 10 раз вырос (<span class="math inline">10/1</span>). Если мы опрометчиво усредним эти соотношения <span class="math inline">(1/10 + 10/1)/2 = 5.05</span>, то получится, что уровень экспрессии в среднем вырос в 5 раз — ерунда. Правильней было бы посчитать средний уровень экспрессии до (<span class="math inline">(1 + 10)/2 = 5.5</span>) и после (<span class="math inline">(10 + 1)/2 = 5.5</span>) и только потом посчитать их соотношение. Тогда мы получили бы гораздо более логичный результат: на самом деле соотношение уровней эеспрессии не изменилось (<span class="math inline">5.5/5.5 = 1</span>).</p>
<p>Соотношения сырых данных экспрессии брать неудобно, потому что обычные соотношения распределены несимметрично вокруг 1. Сравните, например соотношения: <span class="math inline">1/5 = 0.2</span>, <span class="math inline">5/5 = 1</span> и <span class="math inline">5/1 = 5</span>. Гораздо удобнее брать логарифм соотношения, потому что его величина распределена симметрично вокруг нуля (и тогда <span class="math inline"><em>l</em><em>o</em><em>g</em>(<em>X</em>) =  − 1 * <em>l</em><em>o</em><em>g</em>(1/<em>X</em>)</span>). Действительно, в нашем примере будет так: <span class="math inline"><em>l</em><em>o</em><em>g</em>(1/5) =  − 1.6</span>, <span class="math inline"><em>l</em><em>o</em><em>g</em>(5/5) = 0</span> и <span class="math inline"><em>l</em><em>o</em><em>g</em>(5/1) = 1.6</span>.</p>
<p>По свойствам логарифмов <span class="math inline"><em>l</em><em>o</em><em>g</em>(<em>a</em>/<em>b</em>) = <em>l</em><em>o</em><em>g</em>(<em>a</em>) − <em>l</em><em>o</em><em>g</em>(<em>b</em>)</span> — это и есть соотношение уровней экспрессии. Обычно, данные логарифмируют при помощи логарифма по основанию 2 — <code>log2()</code>, чтобы облегчить сравнение уровней экспрессии. Если экспрессия в 2 раза отличается между образцами, получится, что <span class="math inline"><em>l</em><em>o</em><em>g</em>2(2<em>x</em>/<em>x</em>) = <em>l</em><em>o</em><em>g</em>2(2) = 1</span>.</p>
<p>Основная проблема использования соотношения уровней экспрессии — метод позволяет выбрать белки, у которых самая большая разница экспрессии, но не позволяет проверить статистическую значимость различий. На самом деле, при наличии повторностей лучше использовать другие методы оценки статистической значимости различий уровней экспрессии.</p>
</div>
</div>
<div id="t-" class="section level2">
<h2>t-тест</h2>
<p>Чтобы проверить гипотезу <span class="math inline"><em>H</em><sub>0</sub> : <em>Ā</em> − <em>B̄</em> = 0</span>, нужно оценить дисперсию в генеральной совокупности <span class="math inline"><em>σ</em></span>. После этого можно воспользоваться t-критерий.</p>
<p><strong>t-критерий</strong></p>
<p><br /><span class="math display">$$t = \frac {\bar {A} - \bar {B}} {\sqrt{s^{2}}}$$</span><br /></p>
<p>Обычный t-тест исходит из предположения, что дисперсии в группах одинаковы. Обычно, это предположение нереалистично. Мы будем использовать модификацию t-теста для разных дисперсий в группах — т.наз. t-критерий Велша (Welch’s t-test).</p>
<table>
<colgroup>
<col width="45%" />
<col width="27%" />
<col width="27%" />
</colgroup>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center">Группа А</th>
<th align="center">Группа B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">Наблюдения</td>
<td align="center"><br /><span class="math display"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ..., <em>a</em><sub><em>n</em></sub></span><br /></td>
<td align="center"><br /><span class="math display"><em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ..., <em>b</em><sub><em>m</em></sub></span><br /></td>
</tr>
<tr class="even">
<td align="center">Средние значения</td>
<td align="center"><br /><span class="math display">$$\bar{A} = \frac {\sum{a_i}} {n}$$</span><br /></td>
<td align="center"><br /><span class="math display">$$\bar{B} = \frac {\sum{b_i}} {m}$$</span><br /></td>
</tr>
<tr class="odd">
<td align="center">Дисперсии</td>
<td align="center"><br /><span class="math display">$$s^2_a = \frac {\sum{a_i - \bar{A}}} {n - 1}$$</span><br /></td>
<td align="center"><br /><span class="math display">$$s^b_b = \frac {\sum{b_i - \bar{B}}} {m - 1}$$</span><br /></td>
</tr>
</tbody>
</table>
<p><strong>t-критерий для случая неравных дисперсий</strong> (Welch’s t-test)</p>
<p><br /><span class="math display">$$t = \frac {\bar {A} - \bar {B}} {\sqrt{\frac{s^{2}_{a}}{n} + \frac{s^{2}_{b}}{m}}}$$</span><br /></p>
<p>Если исходные данные распределены нормально, то t-статистика подчиняется t-распределению с числом степеней свободы df, которое рассчитывается по уравнению Уэлча-Саттеруэйта</p>
<p><br /><span class="math display">$$df_{ Welch–Satterthwaite} \approx \frac {\Big(\frac{s^2_1}{n_1} + \frac{s^2_2}{n_2}\Big)^2} {\frac {s_1^4} {n^2_1 \cdot df_1} + \frac {s_2^4} {n^2_2 \cdot df_1}}$$</span><br /></p>
<p>Далее при t-тесте следуют действия, обычные при тестировании гипотез:</p>
<ul>
<li>Считаем t-статистику.</li>
<li>Считаем вероятность получить такое значение статистики при условии, что нулевая гипотеза верна (доверительную вероятность, p-value).</li>
<li>Сравниваем доверительную вероятность вероятность с заданным критическим уровнем значимости (<span class="math inline"><em>α</em></span>). Если эта вероятность меньше заданного уровня значимости — отвергаем нулевую гипотезу.</li>
</ul>
<div id="t---r" class="section level3">
<h3>t-тест в R</h3>
<p>Давайте сравним уровень экспрессии первого белка между группами при помощи простого t-критерия.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1">groups &lt;-<span class="st"> </span>pecten.fac<span class="op">$</span>Condition <span class="op">==</span><span class="st"> &quot;15C&quot;</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="kw">t.test</span>(<span class="dt">x =</span> pecten_norm[<span class="dv">1</span>, groups], <span class="dt">y =</span> pecten_norm[<span class="dv">1</span>, <span class="op">!</span>groups])</a></code></pre></div>
<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  pecten_norm[1, groups] and pecten_norm[1, !groups]
## t = -0.03865, df = 9.6865, p-value = 0.97
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -1.511069  1.459762
## sample estimates:
## mean of x mean of y 
##  22.06317  22.08882</code></pre>
<p>Но у нас всего 766 белков — давайте посчитаем t-тест для каждого белка. Для этого нам понадобится написать функцию, которая считает t-test и добывает p-value из его результатов, затем применить ее к каждой строке данных.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="co"># 1) пишем функцию, которая считает t-test и добывает p-value</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">t_p_val &lt;-<span class="st"> </span><span class="cf">function</span>(x, f1, f2) {</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">  <span class="kw">tryCatch</span>(<span class="kw">t.test</span>(<span class="dt">x =</span> x[f1], <span class="dt">y =</span> x[f2])<span class="op">$</span>p.value,</a>
<a class="sourceLine" id="cb52-4" data-line-number="4">           <span class="dt">error =</span> <span class="cf">function</span>(e) <span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb52-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb52-6" data-line-number="6"><span class="co"># # тестируем функцию</span></a>
<a class="sourceLine" id="cb52-7" data-line-number="7"><span class="co"># t_p_val(pecten_norm[1, ], f1 = groups, f2 = !groups)</span></a>
<a class="sourceLine" id="cb52-8" data-line-number="8"></a>
<a class="sourceLine" id="cb52-9" data-line-number="9"><span class="co"># 2) к каждой строке данных применяем наш t.test</span></a>
<a class="sourceLine" id="cb52-10" data-line-number="10">pvals &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X =</span> pecten_norm, <span class="dt">MARGIN =</span> <span class="dv">1</span>, <span class="dt">FUN =</span> t_p_val, </a>
<a class="sourceLine" id="cb52-11" data-line-number="11">               <span class="dt">f1 =</span> groups, <span class="dt">f2 =</span> <span class="op">!</span>groups)</a></code></pre></div>
<p>Все готово, в результате мы посчитали вектор p-values для всех белков.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="kw">head</span>(pvals)</a></code></pre></div>
<pre><code>##        126        155        168        285        315        328 
## 0.96995469 0.62340389 0.14467327 0.47208082 0.30725030 0.07513191</code></pre>
<p>Сколько белков, достоверно меняющих экспрессию, мы нашли?</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="kw">sum</span>(pvals <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## [1] 25</code></pre>
<p>Экспрессия каких белков различается?</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="kw">rownames</span>(pecten_norm)[<span class="kw">which</span>(pvals <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)]</a></code></pre></div>
<pre><code>##  [1] &quot;819&quot;  &quot;832&quot;  &quot;835&quot;  &quot;1145&quot; &quot;1471&quot; &quot;1646&quot; &quot;1732&quot; &quot;1767&quot; &quot;1796&quot; &quot;1900&quot;
## [11] &quot;1962&quot; &quot;2299&quot; &quot;2468&quot; &quot;2489&quot; &quot;2607&quot; &quot;2747&quot; &quot;2942&quot; &quot;2932&quot; &quot;3006&quot; &quot;1073&quot;
## [21] &quot;1709&quot; &quot;1721&quot; &quot;1833&quot; &quot;1926&quot; &quot;2257&quot;</code></pre>
<p>Проблема в том, что <strong>это неправильные доверительные вероятности!</strong> Мы сделали множество тестов, и теперь необходимо внести поправку на множественное тестирование.</p>
</div>
<div id="---." class="section level3">
<h3>Поправки на множественное тестирование.</h3>
<p>В результате протеомного исследования обычно получают данные об экспрессии сотен–тысяч белков. При анализе дифференциальной экспрессии для каждого белка нам нужно протестировать нулевую гипотезу <span class="math inline"><em>H</em><sub>0</sub> : <em>Ā</em> = <em>B̄</em></span>.</p>
<p>В случае, если у нас всего один белок — мы делаем всего один статистический тест. В этом единственном тесте мы заранее фиксируем вероятность совершить ошибку I рода на уровне значимости <span class="math inline"><em>α</em> = 0.05</span> (или <span class="math inline"><em>α</em> = 0.01</span>).</p>
<p>Но представьте себе, что мы сравниваем уровень экспрессии 1000 белков. Даже если на самом деле их экспрессия не различается в двух группах (<span class="math inline"><em>H</em><sub>0</sub></span> на самом деле справедлива), мы получим по крайней мере в 50 из этих тестов <span class="math inline"><em>p</em> &lt; 0.05</span>. Т.е. в 50 из 1000 тестов мы совершим ошибку I рода — найдем различия экспрессии там, где их нет. Это непозволительно большое количество ошибок.</p>
<p>Если вероятность ошибки I рода <span class="math inline"><em>α</em> = 0.05</span>, тогда вероятность не совершить ошибку первого рода <span class="math inline">1 − <em>α</em></span>. Вероятность не совершить ошибку первого рода ни в одном из сравнений <span class="math inline">(1 − <em>α</em>)<sup><em>m</em></sup></span>. Вероятность совершить хотябы одну ошибку первого рода в группе сравнений <span class="math inline">1 − (1 − <em>α</em>)<sup><em>m</em></sup></span>.</p>
<table>
<colgroup>
<col width="19%" />
<col width="25%" />
<col width="55%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Если не делать поправок на число сравнений…</th>
<th align="center">1 сравнение</th>
<th align="center">семейство из 1000 сравнений</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">Число ошибок I рода на число сравнений<br />Per comparison error rate</td>
<td align="center">0.05</td>
<td align="center">0.05</td>
</tr>
<tr class="even">
<td align="center">Ожидаемое число ошибок <br /> Per family error rate</td>
<td align="center">0.05</td>
<td align="center">0.05 * 1000 = 50</td>
</tr>
<tr class="odd">
<td align="center">Вероятность получить хотябы одну ошибку I рода <br /> Family-wise error rate (FWER)</td>
<td align="center">0.05</td>
<td align="center"><br /><span class="math display">1 − (1 − 0.05)<sup>1000</sup> = 1</span><br /></td>
</tr>
</tbody>
</table>
<div id="-------i----." class="section level4">
<h4>Контроль вероятности получить хотя бы одну ошибку I рода в группе сравнений.</h4>
<p><strong>Вероятность получить хотябы одну ошибку I рода в группе сравнений (Family-wise error rate, FWER)</strong> можно зафиксировать на каком-нибудь приемлемом уровне. Примеры таких процедур — поправка Бонферрони и метод Хольма-Бонферрони.</p>
<p><strong>Поправка Бонферрони</strong> — процедура в один шаг. Отклоняем все нулевые гипотезы, для которых <span class="math inline">$p \le \frac {\alpha} {m}$</span>. Например, если вам нужно сделать 1000 сравнений, чтобы вероятность совершить ошибку I рода была 0.05, то нужно использовать <span class="math inline"><em>p</em> = 0.05/1000 = 0.00005</span> для каждого сравнения. Это очень жесткая поправка.</p>
<p><strong>Метод Хольма-Бонферрони</strong> — это способ ввести более мягкие поправки при помощи пошаговой процедуры. Чтобы зафиксировать <span class="math inline"><em>F</em><em>W</em><em>E</em><em>R</em> ≤ <em>α</em></span> мы сначала сортируем {p_n} p-values, полученные в тестах, в порядке возрастания <span class="math inline"><em>p</em><sub>1</sub> ≤ <em>p</em><sub>2</sub> ≤ ⋯ ≤ <em>p</em><sub><em>n</em> − 1</sub> ≤ <em>p</em><sub><em>n</em></sub></span>. Затем вводим поправку для уровня значимости <span class="math inline">$\hat{p_{j}} = min{\{(n - j + 1) \cdot p_{j}, 1\}}$</span></p>
<p>В таблице приведены результаты нескольких сравнений. Для каждой из доверительных вероятностей мы получим свой порог значимости при помощи поправки Хольма-Бонферрони:</p>
<table>
<thead>
<tr class="header">
<th align="right">Ранг (<span class="math inline"><em>j</em></span>)</th>
<th align="right"><span class="math inline"><strong>p</strong><sub><strong>j</strong></sub></span></th>
<th align="right"><span class="math inline">(<em>n</em> − <em>j</em> + 1)</span></th>
<th align="right"><span class="math inline">$\mathbf{\hat{p_{j}}}$</span></th>
<th align="left">Отвергаем <span class="math inline"><em>H</em><sub>0</sub></span>?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">5</td>
<td align="right">0.015</td>
<td align="right">1</td>
<td align="right">0.015</td>
<td align="left">Да</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">0.010</td>
<td align="right">2</td>
<td align="right">0.020</td>
<td align="left">Да</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">0.035</td>
<td align="right">3</td>
<td align="right">0.105</td>
<td align="left">Нет</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">0.040</td>
<td align="right">4</td>
<td align="right">0.160</td>
<td align="left">Нет</td>
</tr>
<tr class="odd">
<td align="right">1</td>
<td align="right">0.046</td>
<td align="right">5</td>
<td align="right">0.230</td>
<td align="left">Нет</td>
</tr>
</tbody>
</table>
<p>Недостаток применения процедур контроля FWER — снижение мощности всех тестов: мы каким либо способом снижаем <span class="math inline"><em>α</em></span> для каждого сравнения, в результате возрастает <span class="math inline"><em>β</em></span>, а значит снижается мощность <span class="math inline">1 − <em>β</em></span>.</p>
<p>Процедуры контроля FWER неоправданно жесткие. Они контролируют вероятность возникновения <strong>хотябы одной</strong> ошибки первого рода в группе сравнений. Эти процедуры устроены так, как будто мы проверяем обобщенную нулевую гипотезу — об отсутствии различий во всех сравнениях. На самом деле, эта гипотеза редко интересна с практической точки зрения. Считается, что небольшое число ошибок I рода все же можно допустить (например, при анализе геномных или протеомных данных). Именно поэтому часто указывают не уровни значимости после коррекции на множественные сравнения, а частоту ложноположительных результатов (частоту возникновения ошибок I рода).</p>
</div>
<div id="---." class="section level4">
<h4>Контроль частоты ложноположительных результатов.</h4>
<p><strong>Частота ложноположительных результатов (false discovery rate, FDR)</strong> — это доля ошибок I рода относительно общего числа отвегнутых <span class="math inline"><em>H</em><sub>0</sub></span>.</p>
<p>Для контроля FDR используется <strong>процедура Беньямини-Хохберга</strong>. Чтобы зафиксировать <span class="math inline"><em>F</em><em>D</em><em>R</em> ≤ <em>γ</em></span> мы сначала сортируем в порядке возрастания {p_n} доверительных вероятностей <span class="math inline"><em>p</em><sub>1</sub> ≤ <em>p</em><sub>2</sub> ≤ ⋯ ≤ <em>p</em><sub><em>n</em> − 1</sub> ≤ <em>p</em><sub><em>n</em></sub></span>. Затем, находим такое значение p-value с наибольшим рангом <span class="math inline"><em>j</em></span>, чтобы <span class="math inline">$p_{j} \le \frac{j}{n}\times \gamma$</span>. Результаты всех тестов с рангами меньше <span class="math inline"><em>j</em></span> считаем значимыми.</p>
<p>Для каждого теста можно вычислить точную ожидаемую долю ложноположительных результатов. <span class="math inline"><strong>q</strong> <strong>−</strong> <strong>v</strong><strong>a</strong><strong>l</strong><strong>u</strong><strong>e</strong></span> — минимальное значение FDR при котором результат конкретного теста можно считать значимым (Storey 2002, Storey Tibshirani 2003). Например, для 15 сравнений результаты процедуры Беньямини-Хохберга могут выглядеть так:</p>
<table>
<colgroup>
<col width="12%" />
<col width="19%" />
<col width="40%" />
<col width="19%" />
<col width="8%" />
</colgroup>
<thead>
<tr class="header">
<th align="right">Ранг (<span class="math inline"><em>j</em></span>)</th>
<th align="right"><span class="math inline"><strong>p</strong><sub><strong>j</strong></sub></span></th>
<th align="right"><span class="math inline">$\mathbf{\frac{j}{n}\times \gamma}$</span></th>
<th align="left">Отвергаем <span class="math inline"><em>H</em><sub>0</sub></span>?</th>
<th align="right">q-value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">0.0003</td>
<td align="right">0.0033333</td>
<td align="left">Да</td>
<td align="right">0.0045</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">0.0015</td>
<td align="right">0.0066667</td>
<td align="left">Да</td>
<td align="right">0.0112</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">0.0074</td>
<td align="right">0.0100000</td>
<td align="left">Да</td>
<td align="right">0.0370</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">0.0291</td>
<td align="right">0.0133333</td>
<td align="left">Нет</td>
<td align="right">0.1091</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">0.0661</td>
<td align="right">0.0166667</td>
<td align="left">Нет</td>
<td align="right">0.1983</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">0.1923</td>
<td align="right">0.0200000</td>
<td align="left">Нет</td>
<td align="right">0.4808</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="right">0.2972</td>
<td align="right">0.0233333</td>
<td align="left">Нет</td>
<td align="right">0.6369</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0.3599</td>
<td align="right">0.0266667</td>
<td align="left">Нет</td>
<td align="right">0.6748</td>
</tr>
<tr class="odd">
<td align="right">9</td>
<td align="right">0.4955</td>
<td align="right">0.0300000</td>
<td align="left">Нет</td>
<td align="right">0.8258</td>
</tr>
<tr class="even">
<td align="right">10</td>
<td align="right">0.5687</td>
<td align="right">0.0333333</td>
<td align="left">Нет</td>
<td align="right">0.8530</td>
</tr>
<tr class="odd">
<td align="right">11</td>
<td align="right">0.6434</td>
<td align="right">0.0366667</td>
<td align="left">Нет</td>
<td align="right">0.8774</td>
</tr>
<tr class="even">
<td align="right">12</td>
<td align="right">0.7151</td>
<td align="right">0.0400000</td>
<td align="left">Нет</td>
<td align="right">0.8939</td>
</tr>
<tr class="odd">
<td align="right">13</td>
<td align="right">0.8947</td>
<td align="right">0.0433333</td>
<td align="left">Нет</td>
<td align="right">1.0000</td>
</tr>
<tr class="even">
<td align="right">14</td>
<td align="right">0.9441</td>
<td align="right">0.0466667</td>
<td align="left">Нет</td>
<td align="right">1.0000</td>
</tr>
<tr class="odd">
<td align="right">15</td>
<td align="right">1.0000</td>
<td align="right">0.0500000</td>
<td align="left">Нет</td>
<td align="right">1.0000</td>
</tr>
</tbody>
</table>
</div>
<div id="-fwer--fdr--r" class="section level4">
<h4>Контроль FWER и FDR в R</h4>
<p>Поправки к p-values в R можно сделать при помощи функции <code>p.adjust()</code></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb59-1" data-line-number="1">p_bonf &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pvals, <span class="dt">method =</span> <span class="st">&quot;bonferroni&quot;</span>)</a></code></pre></div>
<p>У скольких белков экспрессия достоверно различается после поправки Бонферрони?</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="kw">sum</span>(p_bonf <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>Названия белков, экспрессия которых достоверно различается после поправки Бонферрони?</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">names</span>(pvals)[p_bonf <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>]</a></code></pre></div>
<pre><code>## [1] NA     &quot;1646&quot;</code></pre>
<p>Аргумент <code>method</code> функции <code>p.adjust()</code> задает тип поправки.</p>
<p>Давайте посчитаем, сколько достоверно различающихся белков будет найдено после поправки Хольма</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" data-line-number="1">p_holm &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pvals, <span class="dt">method =</span> <span class="st">&quot;holm&quot;</span>)</a>
<a class="sourceLine" id="cb64-2" data-line-number="2"><span class="kw">sum</span>(p_holm <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>и сколько — после применения процедуры Беньямини-Хохберга</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" data-line-number="1">p_bh &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pvals, <span class="dt">method =</span> <span class="st">&quot;BH&quot;</span>)</a>
<a class="sourceLine" id="cb66-2" data-line-number="2"><span class="kw">sum</span>(p_bh <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## [1] 1</code></pre>
</div>
</div>
<div id="-t-" class="section level3">
<h3>Модерированный t-критерий</h3>
<p>Использование обычного t-критерия не очень удачно для протеомных данных.</p>
<p>Во-первых, может быть <strong>разная дисперсия экспрессии у разных белков</strong>. Часто оказывается, что большая разница уровней экспрессии наблюдается у белков с низким уровнем экспрессии. Из-за этой особенности данных простое применение t-критерия может привести к некорректным выводам. Например, даже ничтожные различия уровня экспрессии могут оказаться достоверными для белков с небольшой дисперсией экспрессии (т.к. небольшие стандартные ошибки). Или же очень сильные различия уровня экспрессии могут оказаться недостоверными для белков с большой дисперсией экспрессии (т.к. стандартные ошибки будут велики).</p>
<p>Во-вторых, <strong>оценка дисперсии экспрессии может быть неточной</strong>. При рассчете обычного t-критерия для оценки дисперсии экспрессии белков используется выборочная оценка дисперсии. Если повторностей мало, оценки дисперсии получаются нестабильными и неточными. t-критерий лучше работает при <strong>большом</strong> числе повторностей, т.к. удается точнее оценить <span class="math inline"><em>σ</em></span></p>
<p>Модерированный t-критерий (moderated t-test) борется с этими недостатками, позволяя для оценки дисперсии использовать информацию о других белках. С учетом распределения возможных значений дисперсии для белков оцениваются “поправленные” стандартные отклонения (shrunk standard deviations)</p>
<p><br /><span class="math display">$$\tilde{s}^{2}_{i} = \frac {s^{2}_{i} d_{i} + s^{2}_{0} d_{0}} {d_{i} + d_{0}}$$</span><br /> <span class="math inline"><em>s</em><sub><em>i</em></sub><sup>2</sup></span> — наблюдаемая дисперсия экспрессии i-того белка; <span class="math inline"><em>s</em><sub>0</sub><sup>2</sup></span> — ожидаемое значение дисперсии экспрессии, оцененное по всему массиву белков; <span class="math inline"><em>d</em><sub><em>i</em></sub></span> и <span class="math inline"><em>d</em><sub><em>o</em></sub></span> — весовые коэффициенты, которые регулируют степень поправки, при малых выборках больший вес несет ожидаемое значение дисперсиии, при больших выборках — наблюдаемая дисперсия.</p>
<p>Модерированный t-критерий испольюует “поправленные” стандартные отклонения для стандартизации разницы логарифмов экспрессии.</p>
<p><br /><span class="math display">$$\tilde{t}_{i} = \frac {(\bar {A}_{i} - \bar {B}_{i})} {\tilde{s}_{i}\sqrt{c_{i}}}$$</span><br /></p>
<p>После его применения не будет случаев, когда t-статистика велика просто потому, что стандартная ошибка оказалась маленькой.</p>
</div>
<div id="-----limma--r" class="section level3">
<h3>Анализ дифференциальной экспрессии в пакете limma в R</h3>
<p>Модерированный t-критерий, как и обычный, можно использовать для оценки значимости коэффициентов линейных моделей (дисперсионный и регрессионный анализ) . Мы найдем дифференциально-экспрессируемые белки при помощи простой линейной модели:</p>
<p><br /><span class="math display"><em>ŷ</em><sub><em>i</em></sub> = <em>b</em><sub>0</sub> + <em>b</em><sub>1</sub><em>x</em><sub>1<em>i</em></sub> + <em>ϵ</em><sub><em>i</em></sub></span><br /></p>
<p>В нем <span class="math inline"><em>ŷ</em><sub><em>i</em></sub></span> — зависимая переменная, уровень экспрессии, <span class="math inline"><em>b</em><sub>0</sub></span> и <span class="math inline"><em>b</em><sub>1</sub></span> - коэффициенты, <span class="math inline"><em>x</em><sub>1<em>i</em></sub></span> — независимая переменная (предиктор, фактор), описывающая принадлежность гребешка к группе, <span class="math inline"><em>ϵ</em><sub><em>i</em></sub></span> — остатки от линейной регрессии, <span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span> — значения.</p>
<p>Поскольку мы сравниваем всего два состояния фактора, их можно закодировать при помощи одного единственного предиктора <span class="math inline"><em>x</em><sub>1<em>i</em></sub></span>. Этот предиктор будет принимать значение 0 на базовом уровне фактора (для гребешков при 15 градусах), и значение 1 на другом уровне (для гребешков при 25 градусах). В таком случае, коэффициент <span class="math inline"><em>b</em><sub>0</sub></span> будет означать уровень экспрессии на базовом уровне фактора, а коэффициент <span class="math inline"><em>b</em><sub>1</sub></span> — разницу уровней экспрессии между двумя уровнями фактора. Таким образом, чтобы выяснить, есть ли разница уровней экспрессии в двух группах, нужно всего лишь протестировать <span class="math inline"><em>H</em><sub>0</sub> : <em>b</em><sub>1</sub> = 0</span> при помощи модерированного t-критерия.</p>
<p>Уравнение линейной регрессии можно переписать в виде матриц:</p>
<p><br /><span class="math display">$$\left[\begin{array}{c}
\hat y_1 \\ \hat y_2 \\ \vdots \\ \hat y_n 
\end{array}\right] = 
\left[\begin{array}{cc}
1 &amp; x_{1,1} \\
1 &amp; x_{2,1} \\
\vdots &amp; \vdots \\
1 &amp; x_{n,1} 
\end{array}\right] \cdot
\left[\begin{array}{c}
b _0 \\ b _1
\end{array}\right] +
\left[\begin{array}{c}
\epsilon _1 \\ \epsilon _2 \\ \vdots \\ \epsilon _n
\end{array}\right]
$$</span><br /></p>
<p>Сокращенная форма записи линейной регрессии в матричном виде выглядит так: <span class="math inline"><strong>ŷ</strong> = <strong>X</strong><strong>b</strong> + <strong>ϵ</strong></span>.</p>
<p>Модерированный t-тест для линейных моделей реализован в пакете <code>limma</code> <span class="citation">(Ritchie et al. 2015)</span> на Bioconductor.</p>
<p>Чтобы подобрать в R линейную модель экспрессии, нужно будет создать модельную матрицу <span class="math inline"><strong>X</strong></span>. Затем при помощи функции <code>lmFit()</code> мы подберем коэффициенты линейной регрессии.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="co"># Создаем модельную матрицу</span></a>
<a class="sourceLine" id="cb68-2" data-line-number="2">X &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>Condition, <span class="dt">data =</span> pecten.fac)</a>
<a class="sourceLine" id="cb68-3" data-line-number="3"><span class="co"># Подбираем линейную модель для каждого белка</span></a>
<a class="sourceLine" id="cb68-4" data-line-number="4">fit &lt;-<span class="st"> </span><span class="kw">lmFit</span>(pecten, <span class="dt">design =</span> X, <span class="dt">method =</span> <span class="st">&quot;robust&quot;</span>, <span class="dt">maxit =</span> <span class="dv">1000</span>)</a></code></pre></div>
<p>Поскольку в этом примере мы сравниваем всего два уровня фактора, чтобы проверить, различается ли экспрессия какого-либо белка между ними, нужно будет всего лишь проверить значимость второго коэффициента линейной модели <span class="math inline"><em>b</em><sub>1</sub></span> (это второй коэффициент). Это мы сделаем как раз при помощи модерированного t-критерия.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="co"># Empirical Bayes statistics</span></a>
<a class="sourceLine" id="cb69-2" data-line-number="2">efit &lt;-<span class="st"> </span><span class="kw">eBayes</span>(fit)</a></code></pre></div>
<p>Наконец, при помощи функции topTable() мы отберем дифференциально-экспрессируемые белки. Поскольку мы по-прежнему тестируем много белков сразу, limma автоматически сделает FDR поправку на множественные сравнения. Вот первые 10 белков, отсортированные по величине <span class="math inline"><em>B</em></span></p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="kw">topTable</span>(efit, <span class="dt">coef =</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##           logFC   AveExpr          t      P.Value    adj.P.Val        B
## 869   -710222.8  766784.6  -6.311552 6.494619e-05 2.487439e-02 -4.59512
## 3001 -1446765.0 1850828.6 -14.064074 3.060504e-08 2.344346e-05 -4.59512
## 1892  -367571.3  543680.5  -5.145676 3.497305e-04 6.697339e-02 -4.59512
## 2257 -5818761.1 8238266.8  -4.483646 9.908123e-04 1.071106e-01 -4.59512
## 3066 -2963840.4 3298221.0  -4.316834 1.300486e-03 1.093112e-01 -4.59512
## 2074  -511221.9  897096.8  -4.251455 1.448227e-03 1.093112e-01 -4.59512
## 2500 -1502230.1 2807961.2  -3.858479 2.796683e-03 1.644926e-01 -4.59512
## 1767 -4447048.5 5429628.7  -5.630027 1.698076e-04 4.335755e-02 -4.59512
## 1797  -254864.9  800064.0  -4.202719 1.569744e-03 1.093112e-01 -4.59512
## 2388  -600310.0  878259.6  -4.484740 9.890588e-04 1.071106e-01 -4.59512</code></pre>
<p>Полную таблицу белков с результатами всех тестов можно вывести, если задать общее число белков в данных. Удобно не сортировать строки этой таблицы, т.к. их порядок будет соответствовать порядку в исходных данных.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb72-1" data-line-number="1">num_spots &lt;-<span class="st"> </span><span class="kw">nrow</span>(pecten)</a>
<a class="sourceLine" id="cb72-2" data-line-number="2">full_list &lt;-<span class="st"> </span><span class="kw">topTable</span>(efit, <span class="dt">coef =</span> <span class="dv">2</span>, <span class="dt">number =</span> num_spots, <span class="dt">sort.by =</span> <span class="st">&quot;none&quot;</span>)</a></code></pre></div>
<p>При желании, можно сохранить список всех (или не всех) белков в файл.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="co"># Сохраняем список всех белков в файл</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2"><span class="kw">write.csv</span>(full_list, <span class="dt">file =</span> <span class="st">&quot;pecten_diff_expression.csv&quot;</span>)</a>
<a class="sourceLine" id="cb73-3" data-line-number="3"><span class="co"># Прочесть файл можно будет так</span></a>
<a class="sourceLine" id="cb73-4" data-line-number="4"><span class="co"># my_data &lt;- read.csv(&quot;pecten_diff_expression.csv&quot;, row.names = 1)</span></a></code></pre></div>
<p>Для того, чтобы построить тепловую карту экспрессии, нам понадобятся дифференциально-экспрессируемые белки. Давайте добудем из полного списка белков только те, экспрессия которых значимо меняется (<span class="math inline"><em>α</em> ≤ 0.05</span>).</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb74-1" data-line-number="1">f_dif &lt;-<span class="st"> </span>full_list<span class="op">$</span>adj.P.Val <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span></a>
<a class="sourceLine" id="cb74-2" data-line-number="2"><span class="co"># Фильтруем исходные данные</span></a>
<a class="sourceLine" id="cb74-3" data-line-number="3">dif_pecten &lt;-<span class="st"> </span>pecten[f_dif, ]</a></code></pre></div>
<div id="----" class="section level4">
<h4>Тепловая карта экспрессии дифференциальных белков</h4>
<p>Палитры для тепловых карт</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb75-1" data-line-number="1"><span class="kw">library</span>(gplots)</a></code></pre></div>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb76-1" data-line-number="1"><span class="co"># Для &quot;сырых данных&quot;</span></a>
<a class="sourceLine" id="cb76-2" data-line-number="2">pal_green &lt;-<span class="st"> </span><span class="kw">colorpanel</span>(<span class="dv">75</span>, <span class="dt">low =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">mid =</span> <span class="st">&quot;darkgreen&quot;</span>, <span class="dt">high =</span> <span class="st">&quot;yellow&quot;</span>)</a>
<a class="sourceLine" id="cb76-3" data-line-number="3"></a>
<a class="sourceLine" id="cb76-4" data-line-number="4"><span class="kw">heatmap.2</span>(<span class="dt">x =</span> <span class="kw">as.matrix</span>(dif_pecten), <span class="dt">col =</span> pal_green, <span class="dt">scale =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">key=</span><span class="ot">TRUE</span>, <span class="dt">symkey =</span> <span class="ot">FALSE</span>, <span class="dt">density.info =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">trace =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">cexRow =</span> <span class="fl">0.9</span>, <span class="dt">cexCol =</span> <span class="dv">1</span>, <span class="dt">margins =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>), <span class="dt">keysize =</span> <span class="fl">0.8</span>, <span class="dt">key.par =</span> <span class="kw">list</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="fl">0.1</span>, <span class="dv">3</span>, <span class="fl">0.1</span>)))</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-51-1.png" width="672" /></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb77-1" data-line-number="1"><span class="co"># Для стандартизованных данных</span></a>
<a class="sourceLine" id="cb77-2" data-line-number="2">pal_blue_red &lt;-<span class="st"> </span><span class="kw">colorpanel</span>(<span class="dv">75</span>, <span class="dt">low =</span> <span class="st">&quot;steelblue&quot;</span>, <span class="dt">mid =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">high =</span> <span class="st">&quot;red&quot;</span>)</a>
<a class="sourceLine" id="cb77-3" data-line-number="3"></a>
<a class="sourceLine" id="cb77-4" data-line-number="4"><span class="kw">heatmap.2</span>(<span class="dt">x =</span> <span class="kw">as.matrix</span>(dif_pecten), <span class="dt">col =</span> pal_blue_red, <span class="dt">scale =</span> <span class="st">&quot;row&quot;</span>, <span class="dt">key =</span> <span class="ot">TRUE</span>, <span class="dt">symkey =</span> <span class="ot">FALSE</span>, <span class="dt">density.info =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">trace =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">cexRow =</span> <span class="fl">0.9</span>, <span class="dt">cexCol =</span> <span class="dv">1</span>, <span class="dt">margins =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>), <span class="dt">keysize =</span> <span class="fl">0.8</span>, <span class="dt">key.par =</span> <span class="kw">list</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="fl">0.1</span>, <span class="dv">3</span>, <span class="fl">0.1</span>)))</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb78-1" data-line-number="1"><span class="co"># Палитра из оттенков серого</span></a>
<a class="sourceLine" id="cb78-2" data-line-number="2"><span class="kw">library</span>(spatstat)</a>
<a class="sourceLine" id="cb78-3" data-line-number="3">pal_gray &lt;-<span class="st"> </span><span class="kw">to.grey</span>(pal_green, <span class="dt">weights=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb78-4" data-line-number="4"><span class="kw">heatmap.2</span>(<span class="dt">x =</span> <span class="kw">as.matrix</span>(dif_pecten), <span class="dt">col =</span> pal_gray, <span class="dt">scale =</span> <span class="st">&quot;row&quot;</span>, <span class="dt">key =</span> <span class="ot">TRUE</span>, <span class="dt">symkey =</span> <span class="ot">FALSE</span>, <span class="dt">density.info =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">trace =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">cexRow =</span> <span class="fl">0.9</span>, <span class="dt">cexCol =</span> <span class="dv">1</span>, <span class="dt">margins =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>), <span class="dt">keysize =</span> <span class="fl">0.8</span>, <span class="dt">key.par =</span> <span class="kw">list</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="fl">0.1</span>, <span class="dv">3</span>, <span class="fl">0.1</span>)))</a></code></pre></div>
<p><img src="%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BF%D1%80%D0%BE%D1%82%D0%B5%D0%BE%D0%BC%D0%BD%D1%8B%D1%85_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_R_files/figure-html/unnamed-chunk-53-1.png" width="672" /></p>
</div>
</div>
</div>
<div class="section level1 unnumbered">
<h1>Ссылки</h1>
<div id="refs" class="references">
<div id="ref-Artigaud_2013">
<p>Artigaud, S., O. Gauthier, and V. Pichereau. 2013. Identifying differentially expressed proteins in two-dimensional electrophoresis experiments: Inputs from transcriptomics statistical tools. Bioinformatics 29:2729–2734.</p>
</div>
<div id="ref-Galili_2015">
<p>Galili, T. 2015. Dendextend: An r package for visualizing, adjusting, and comparing trees of hierarchical clustering. Bioinformatics.</p>
</div>
<div id="ref-Hastie_2018">
<p>Hastie, T., R. Tibshirani, B. Narasimhan, and G. Chu. 2018. Impute: Impute: Imputation for microarray data.</p>
</div>
<div id="ref-Paradis_2018">
<p>Paradis, E., and K. Schliep. 2018. Ape 5.0: An environment for modern phylogenetics and evolutionary analyses in R. Bioinformatics xx:xxx–xxx.</p>
</div>
<div id="ref-Ritchie_2015">
<p>Ritchie, M. E., B. Phipson, D. Wu, Y. Hu, C. W. Law, W. Shi, and G. K. Smyth. 2015. limma powers differential expression analyses for RNA-sequencing and microarray studies. Nucleic Acids Research 43:e47.</p>
</div>
<div id="ref-Suzuki_2015">
<p>Suzuki, R., and H. Shimodaira. 2015. Pvclust: Hierarchical clustering with p-values via multiscale bootstrap resampling.</p>
</div>
<div id="ref-troyanskaya_missing_2001">
<p>Troyanskaya, O., M. Cantor, G. Sherlock, P. Brown, T. Hastie, R. Tibshirani, D. Botstein, and R. B. Altman. 2001. Missing value estimation methods for DNA microarrays. Bioinformatics 17:520–525.</p>
</div>
</div>
</div>


<!-- some extra javascript for older browsers -->
<script type="text/javascript" src="libs/polyfill.js"></script>


<!-- bizible -->
<script type="text/javascript" src="//cdn.bizible.com/scripts/bizible.js" async=""></script>


<!-- disqus
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'rmarkdown'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

-->


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>


</body>
</html>
